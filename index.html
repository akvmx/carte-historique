<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte Historique - Synchronis√©e avec Obsidian</title>
    
    <!-- Leaflet CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        /* Variables CSS optimis√©es */
        :root {
            --couleur-fond: #ffffff;
            --couleur-texte: #2d3748;
            --couleur-accent: #FFC5D3;
            --couleur-accent-hover: #FFC5D3;
            --couleur-bordure: #e2e8f0;
            --couleur-panneau: #f8fafc;
            --couleur-succes: #e0edc6;
            --couleur-attention: #f59e0b;
            --couleur-erreur: #ef4444;
            
            --espacement-xs: 4px;
            --espacement-sm: 8px;
            --espacement-md: 16px;
            --espacement-lg: 24px;
            --espacement-xl: 32px;
            
            --arrondi-sm: 6px;
            --arrondi-md: 8px;
            --arrondi-lg: 12px;
            
            --ombre-sm: 0 1px 2px rgba(0,0,0,0.05);
            --ombre-md: 0 4px 6px rgba(0,0,0,0.07);
            --ombre-lg: 0 10px 15px rgba(0,0,0,0.1);
            
            --transition-rapide: 0.15s ease;
            --transition-normale: 0.25s ease;
        }

        body.theme-sombre {
            --couleur-fond: #1a202c;
            --couleur-texte: #e2e8f0;
            --couleur-accent: #FFC5D3;
            --couleur-accent-hover: #cf9fab;
            --couleur-bordure: #4a5568;
            --couleur-panneau: #2d3748;
        }

        /* Reset et base */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--couleur-fond);
            color: var(--couleur-texte);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: background-color var(--transition-normale), color var(--transition-normale);
            overflow: hidden;
        }

        /* Header avec indicateur de synchronisation */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--espacement-md);
            background: var(--couleur-panneau);
            border-bottom: 1px solid var(--couleur-bordure);
            box-shadow: var(--ombre-sm);
            position: relative;
            z-index: 1000;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--espacement-sm);
        }

        .logo h1 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--couleur-accent);
        }

        .sync-indicator {
            display: flex;
            align-items: center;
            gap: var(--espacement-xs);
            padding: var(--espacement-xs) var(--espacement-sm);
            background: var(--couleur-succes);
            color: white;
            border-radius: var(--arrondi-sm);
            font-size: 0.8rem;
            font-weight: 500;
        }

        .sync-indicator.syncing {
            background: var(--couleur-attention);
        }

        .sync-indicator.error {
            background: var(--couleur-erreur);
        }

        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .header-controls {
            display: flex;
            gap: var(--espacement-sm);
            align-items: center;
        }

        /* Header avec indicateur de synchronisation */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--espacement-md);
            background: var(--couleur-panneau);
            border-bottom: 1px solid var(--couleur-bordure);
            box-shadow: var(--ombre-sm);
            position: relative;
            z-index: 1000;
            gap: var(--espacement-md);
            flex-wrap: wrap;
        }

        .header-controls {
            display: flex;
            gap: var(--espacement-sm);
            align-items: center;
            flex-shrink: 0;
        }

        /* üïµÔ∏è‚Äç‚ôÄÔ∏è Barre de recherche globale */

        .global-search {
            position: relative;
            flex: 1;
            max-width: 420px;
            min-width: 220px;
        }

        .global-search-input {
            width: 100%;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid var(--couleur-bordure);
            background: rgba(255, 255, 255, 0.9);
            font-size: 0.85rem;
            outline: none;
            transition: box-shadow var(--transition-rapide),
                        border-color var(--transition-rapide),
                        background-color var(--transition-rapide);
        }

        body.theme-sombre .global-search-input {
            background: rgba(15, 23, 42, 0.9);
            color: var(--couleur-texte);
            border-color: var(--couleur-bordure);
        }

        .global-search-input:focus {
            border-color: var(--couleur-accent);
            box-shadow: 0 0 0 2px rgba(255, 197, 211, 0.4);
        }

        .global-search-results {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            max-height: 420px;
            background: var(--couleur-panneau);
            border-radius: 12px;
            border: 1px solid var(--couleur-bordure);
            box-shadow: var(--ombre-lg);
            padding: 6px 0;
            display: none;
            overflow-y: auto;
            z-index: 2000;
        }

        .global-search-results.open {
            display: block;
        }

        .global-search-group {
            padding: 4px 0 6px;
        }

        .global-search-group-title {
            padding: 4px 14px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            opacity: 0.6;
        }

        .global-search-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .global-search-item {
            width: 100%;
            border: none;
            background: transparent;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            text-align: left;
            padding: 6px 14px;
            gap: 2px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .global-search-item:hover {
            background: rgba(148, 163, 184, 0.18);
        }

        .global-search-item-title {
            font-weight: 500;
        }

        .global-search-item-meta {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .global-search-empty {
            padding: 6px 14px;
            font-size: 0.8rem;
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            header {
                flex-direction: column;
                align-items: stretch;
            }

            .main-tabs {
                order: 2;
                width: 100%;
                justify-content: center;
            }

            .global-search {
                order: 3;
                width: 100%;
                max-width: none;
            }

            .header-controls {
                order: 4;
                width: 100%;
                justify-content: flex-end;
            }
        }

        .btn {
            background: var(--couleur-accent);
            color: white;
            border: none;
            padding: var(--espacement-sm) var(--espacement-md);
            border-radius: var(--arrondi-sm);
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all var(--transition-rapide);
            display: flex;
            align-items: center;
            gap: var(--espacement-xs);
        }

        .btn:hover {
            background: var(--couleur-accent-hover);
            transform: translateY(-1px);
            box-shadow: var(--ombre-md);
        }

        .btn-secondary {
            background: var(--couleur-panneau);
            color: var(--couleur-texte);
            border: 1px solid var(--couleur-bordure);
        }

        .btn-secondary:hover {
            background: var(--couleur-bordure);
        }

        /* Layout principal */
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            min-height: 0;   /* √©vite que la carte "pousse" en dehors du viewport */
        }

        .timeline {
            flex-shrink: 0;   /* la timeline garde sa hauteur, la carte s'adapte */
        }

        /* Sidebar avec section Obsidian */
        .sidebar {
            flex: 0 0 320px;              /* largeur de base dans le flex */
            max-width: 320px;
            background: var(--couleur-panneau);
            border-right: 1px solid var(--couleur-bordure);
            overflow-y: auto;
            transition: transform var(--transition-normale), 
                        flex-basis var(--transition-normale), 
                        max-width var(--transition-normale), 
                        padding var(--transition-normale), 
                        border var(--transition-normale);
            position: relative;
            z-index: 100;
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
            flex-basis: 0;       /* ne prend plus de place dans le flex */
            max-width: 0;
            padding: 0;
            border-right: none;
        }

        .sidebar-content {
            padding: var(--espacement-lg);
        }

        .control-section {
            margin-bottom: var(--espacement-xl);
        }

        .control-section h3 {
            margin-bottom: var(--espacement-md);
            color: var(--couleur-accent);
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--espacement-sm);
        }

        /* Section sp√©ciale Obsidian */
        .obsidian-section {
            background: linear-gradient(135deg, #FFC5D3, #cf92a1);
            color: white;
            padding: var(--espacement-lg);
            border-radius: var(--arrondi-lg);
            margin-bottom: var(--espacement-xl);
        }

        .obsidian-section h3 {
            color: white;
            margin-bottom: var(--espacement-md);
        }

        .obsidian-status {
            display: flex;
            align-items: center;
            gap: var(--espacement-sm);
            margin-bottom: var(--espacement-md);
        }

        .obsidian-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--espacement-sm);
        }

        .btn-obsidian {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .btn-obsidian:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        /* Contr√¥les de filtre */
        .range-control {
            background: var(--couleur-fond);
            border: 1px solid var(--couleur-bordure);
            border-radius: var(--arrondi-lg);
            padding: var(--espacement-lg);
        }

        .range-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--espacement-md);
            font-weight: 500;
        }

        .year-display {
            background: var(--couleur-accent);
            color: white;
            padding: var(--espacement-xs) var(--espacement-sm);
            border-radius: var(--arrondi-sm);
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }
        
        .year-input {
            background: var(--couleur-accent);
            color: white;
            border: none;
            padding: var(--espacement-xs) var(--espacement-sm);
            border-radius: var(--arrondi-sm);
            font-weight: 600;
            min-width: 80px;
            text-align: center;
            font-size: 0.9rem;
        }

        .year-input:focus {
            outline: 2px solid white;
            outline-offset: 2px;
        }
        
        .year-input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .range-slider {
            width: 100%;
            height: 6px;
            background: var(--couleur-bordure);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--couleur-accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--ombre-md);
            transition: all var(--transition-rapide);
        }

        .range-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* Frise chronologique horizontale */
        .timeline-horizontal {
            position: relative;
            margin-top: 16px;
            margin-bottom: 16px;
            height: 60px;
            border-top: 2px solid var(--couleur-accent);
        }
        
        /* Les points d'√©v√©nements sur la frise */
        .timeline-point {
            position: absolute;
            top: -5px;
            width: 10px;
            height: 10px;
            background: var(--couleur-accent);
            border-radius: 50%;
            transform: translateX(-50%);
        }
        
        /* Les rep√®res d'ann√©es sous la frise */
        .timeline-year {
            position: absolute;
            top: 12px;
            font-size: 0.75rem;
            transform: translateX(-50%);
            opacity: 0.7;
            white-space: nowrap;
        }
        
        /* Plage pour les √©v√©nements sur plusieurs ann√©es */
        .timeline-range {
            position: absolute;
            top: -3px;
            height: 6px;
            background: var(--couleur-accent);
            border-radius: 3px;
            opacity: 0.7;
        }
        
        /* Boutons de filtre d'affichage */
        .filter-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--espacement-sm);
        }
        
        .timeline-horizontal {
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 30px;
        }
        
        .timeline-track {
            position: relative;
            height: 150px;
            padding: 20px 0 20px 0;
            overflow-x: auto;
            overflow-y: visible;
            border-bottom: 1px solid var(--couleur-bordure);
            background: var(--couleur-panneau);
        }
        
        .timeline-track-inner {
            position: relative;
            height: 100%;
        }

        .timeline-nav {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 var(--espacement-lg);
        }

        /* La frise prend toute la place disponible entre les fl√®ches */
        .timeline-nav .timeline-track {
            flex: 1;
        }
        
        .timeline-arrow {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: 1px solid var(--couleur-bordure);
            background: var(--couleur-fond);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.15s;
        }

        .timeline-arrow:hover {
            background: var(--couleur-accent);
            color: white;
            border-color: var(--couleur-accent);
            transform: translateY(-1px);
        }

        .timeline-axis {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            height: 6px;                      /* √âPAISSEUR DE LA FRISE */
            background: linear-gradient(
                90deg,
                rgba(233, 164, 218, 0.8),
                rgba(196, 107, 181, 0.8)
            );
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
        }
        
        .timeline-year {
            position: absolute;
            top: calc(50% + 18px);
            transform: translateX(-50%);
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--couleur-texte);
            opacity: 0.8;
            text-shadow: 0 1px 2px rgba(255,255,255,0.7);
        }
        
        .timeline-dot {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 18px;  
            height: 18px; 
            background: white;
            border: 4px solid var(--couleur-accent);
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(59,130,246,0.4);  /* halo bleu */
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }

        .timeline-dot:hover {
            transform: translate(-50%, -50%) scale(1.45);
            box-shadow: 0 0 14px rgba(59,130,246,0.6);
        }

        .timeline-dot.selected {
            transform: translate(-50%, -50%) scale(1.8);
            box-shadow: 0 0 18px rgba(59,130,246,0.9);
        }
        
        .timeline-tooltip {
            position: absolute;
            top: 50%;                          
            transform: translate(-50%, -110%); 
            max-width: 220px;
            padding: 4px 8px;               
            background: white;
            color: var(--couleur-texte);
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            font-size: 0.75rem;          
            font-weight: 500;
            white-space: nowrap;              
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 20;
        }
        
        .timeline-tooltip.visible {
            opacity: 1;
        }

        .timeline-event.highlight {
            outline: 2px solid var(--couleur-accent);
            box-shadow: 0 0 0 2px rgba(59,130,246,0.3);
        }

        .btn-filter {
            padding: var(--espacement-sm) var(--espacement-md);
            background: var(--couleur-fond);
            border: 2px solid var(--couleur-bordure);
            border-radius: var(--arrondi-md);
            cursor: pointer;
            text-align: center;
            transition: all var(--transition-rapide);
            font-weight: 500;
            font-size: 0.9rem;
        }

        .btn-filter:hover {
            border-color: var(--couleur-accent);
            transform: translateY(-1px);
            box-shadow: var(--ombre-md);
        }

        .btn-filter.active {
            background: var(--couleur-accent);
            color: white;
            border-color: var(--couleur-accent);
        }

        /* Boutons continents */
        .continent-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--espacement-sm);
        }

        .btn-continent {
            padding: var(--espacement-md);
            background: var(--couleur-fond);
            border: 2px solid var(--couleur-bordure);
            border-radius: var(--arrondi-md);
            cursor: pointer;
            text-align: center;
            transition: all var(--transition-rapide);
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .btn-continent:hover {
            border-color: var(--couleur-accent);
            transform: translateY(-2px);
            box-shadow: var(--ombre-md);
        }

        .btn-continent.active {
            background: var(--couleur-accent);
            color: white;
            border-color: var(--couleur-accent);
        }


        /* Statistiques */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--espacement-md);
        }

        .stat-card {
            background: var(--couleur-fond);
            border: 1px solid var(--couleur-bordure);
            border-radius: var(--arrondi-lg);
            padding: var(--espacement-lg);
            text-align: center;
            transition: all var(--transition-rapide);
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--ombre-md);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--couleur-accent);
            line-height: 1;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--couleur-texte);
            margin-top: var(--espacement-xs);
        }

        /* Zone carte */
        .map-container {
            flex: 1;
            position: relative;
            background: var(--couleur-bordure);
            min-width: 0;  /* important en flex pour √©viter les d√©bordements */
            min-height: 0;
        }

        .notes-panel {
            display: none;
            flex: 1;
            padding: var(--espacement-lg);
            background: var(--couleur-panneau);
            border-left: 1px solid var(--couleur-bordure);
            overflow-y: auto;
        }

        .notes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--espacement-md);
            margin-bottom: var(--espacement-lg);
        }

        .notes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: var(--espacement-md);
        }

        .note-card {
            background: var(--couleur-fond);
            border: 1px solid var(--couleur-bordure);
            border-radius: var(--arrondi-lg);
            padding: var(--espacement-md);
            display: flex;
            flex-direction: column;
            gap: var(--espacement-sm);
            box-shadow: var(--ombre-sm);
            transition: transform var(--transition-rapide), box-shadow var(--transition-rapide);
            cursor: pointer;
        }

        .note-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--ombre-md);
        }

        .note-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .note-meta {
            display: flex;
            gap: var(--espacement-sm);
            flex-wrap: wrap;
            font-size: 0.85rem;
            color: var(--couleur-texte);
            opacity: 0.8;
        }

        .note-description {
            font-size: 0.9rem;
            color: var(--couleur-texte);
            opacity: 0.9;
        }

        #carte {
            width: 100%;
            height: 100%;
            border: none;
        }

        .toggle-sidebar {
            position: absolute;
            top: var(--espacement-md);
            left: var(--espacement-md);
            z-index: 1001;
            background: var(--couleur-panneau);
            border: 1px solid var(--couleur-bordure);
            border-radius: var(--arrondi-sm);
            padding: var(--espacement-sm);
            cursor: pointer;
            box-shadow: var(--ombre-md);
            transition: all var(--transition-rapide);
        }

        .toggle-sidebar:hover {
            background: var(--couleur-accent);
            color: white;
        }

        .timeline-header-right {
            display: flex;
            align-items: center;
            gap: 10px; /* espace entre les onglets et le bouton ‚ñº */
        }

        .timeline-tabs {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* Timeline */
        .timeline {
            height: 400px;
            background: var(--couleur-panneau);
            border-top: 1px solid var(--couleur-bordure);
            display: flex;
            flex-direction: column;
            transition: height var(--transition-normale);
            position: relative;
        }

        .timeline.collapsed {
            height: 50px;
        }

        .timeline-header {
            padding: var(--espacement-md);
            border-bottom: 1px solid var(--couleur-bordure);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--couleur-panneau);
        }

        .timeline-content {
            max-height: 180px;
            overflow-y: auto;
            padding: var(--espacement-md);
        }

        /* ====== STUDIO CHRONOLOGIE ‚Äì VERSION √âPUR√âE ====== */

        /* En vue "chronologie.", la timeline devient une page √† part enti√®re */
        body.view-timeline .timeline {
            display: flex;
            flex-direction: column;
            flex: 1;
            height: calc(100vh - 64px); /* √† ajuster si ton header est plus haut/bas */
            max-height: calc(100vh - 64px);
            background: var(--couleur-fond);
            border-top: none;
            box-shadow: 0 -4px 20px rgba(15, 23, 42, 0.12);
            border-radius: 18px 18px 0 0;
            margin: 8px 12px 0;
            overflow: hidden;
        }

        /* Header de la timeline : plus compact, plus "app" */
        body.view-timeline .timeline-header {
            padding: 10px 18px;
            border-bottom: 1px solid var(--couleur-bordure);
            background: radial-gradient(circle at top left,
                rgba(255, 197, 211, 0.20),
                transparent 60%
            );
        }

        body.view-timeline .timeline-header-left h2 {
            font-size: 1rem;
            text-transform: lowercase;
            margin-bottom: 2px;
        }

        body.view-timeline .timeline-header-left .detail-subtitle {
            font-size: 0.78rem;
        }

        /* Tabs + filtres : align√©s sur une ligne, type "toolbar" */
        body.view-timeline .timeline-header-right {
            gap: 10px;
        }

        body.view-timeline .timeline-tabs .btn {
            font-size: 0.78rem;
            padding: 4px 10px;
            border-radius: 999px;
        }

        /* Les petits champs de filtre p√©riode */
        body.view-timeline .timeline-header-controls {
            gap: 6px;
            font-size: 0.75rem;
        }

        body.view-timeline .timeline-header-controls select,
        body.view-timeline .timeline-header-controls input {
            padding: 3px 8px;
        }

        /* Le bouton ‚ñº de collapse n‚Äôa pas de sens dans ce mode => on le masque */
        body.view-timeline #toggle-timeline {
            display: none;
        }

        /* Layout principal : frise + liste */
        body.view-timeline .timeline-country,
        body.view-timeline .timeline-global {
            flex: 1;
            display: grid;
            grid-template-columns: minmax(260px, 1.1fr) minmax(0, 2.2fr);
            gap: 18px;
            padding: 14px 18px 16px;
            overflow: hidden;
        }

        /* Colonne gauche : nav + grande frise */
        body.view-timeline .timeline-nav {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        body.view-timeline .timeline-track {
            flex: 1;
            border-radius: 14px;
            background: var(--couleur-panneau);
            border: 1px solid var(--couleur-bordure);
            box-shadow: var(--ombre-sm);
            padding: 6px 0;
        }

        /* Fl√®ches ‚óÄ ‚ñ∂ plus discr√®tes */
        body.view-timeline .timeline-arrow {
            align-self: flex-end;
            width: 30px;
            height: 30px;
            font-size: 0.9rem;
        }

        /* Frise : ligne simple, respirante */
        body.view-timeline .timeline-axis {
            height: 4px;
            background: linear-gradient(
                90deg,
                rgba(255, 197, 211, 0.9),
                rgba(209, 213, 219, 0.9)
            );
            border-radius: 999px;
        }

        body.view-timeline .timeline-year {
            font-size: 0.7rem;
            opacity: 0.65;
        }

        /* Points d‚Äô√©v√©nements : plus petits, moins ‚Äúflashy‚Äù */
        body.view-timeline .timeline-dot {
            width: 14px;
            height: 14px;
            border-width: 3px;
            box-shadow: 0 0 6px rgba(15, 23, 42, 0.20);
        }

        body.view-timeline .timeline-dot.selected {
            transform: translate(-50%, -50%) scale(1.5);
            box-shadow: 0 0 12px rgba(15, 23, 42, 0.35);
        }

        /* Tooltip sobre */
        body.view-timeline .timeline-tooltip {
            font-size: 0.75rem;
            padding: 4px 6px;
        }

        /* Colonne droite : liste d‚Äô√©v√©nements */
        body.view-timeline .timeline-content,
        body.view-timeline #timeline-global-content {
            max-height: none;
            background: var(--couleur-panneau);
            border-radius: 14px;
            border: 1px solid var(--couleur-bordure);
            padding: 10px 10px 12px;
            overflow-y: auto;
        }

        /* Cartes d‚Äô√©v√©nements dans la vue chronologie */
        body.view-timeline .timeline-event {
            margin-bottom: 8px;
            padding: 8px 8px;
            border-radius: 10px;
            border-left-width: 3px;
            box-shadow: none;
        }

        body.view-timeline .timeline-event:hover {
            transform: translateX(2px);
            box-shadow: var(--ombre-sm);
        }

        /* Vue "carte" : on garde une timeline compacte en bas (d√©j√† g√©r√©e) */
        body.view-map .timeline {
            height: 260px;
        }

        body.view-map .timeline.collapsed {
            height: 50px;
        }

        /* ========================================
        LISTE "TOUS LES √âV√âNEMENTS" ‚Äî STYLE PRO
        ======================================== */

            .events-list {
                margin-top: var(--espacement-sm);
                padding: var(--espacement-sm);
                background: var(--couleur-fond);
                border-radius: var(--arrondi-lg);
                border: 1px solid var(--couleur-bordure);
                box-shadow: var(--ombre-sm);
                max-height: 350px;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: var(--espacement-md);
            }

            /* --------- ITEM --------- */

            .event-item {
                background: var(--couleur-panneau);
                padding: var(--espacement-md);
                border-radius: var(--arrondi-md);
                border: 1px solid var(--couleur-bordure);
                box-shadow: var(--ombre-xs);
                cursor: pointer;
                transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
                position: relative;
            }

            .event-item:hover {
                transform: translateY(-3px);
                box-shadow: var(--ombre-lg);
            }

            /* --------- BARRE VERTICALE (effet timeline locale) --------- */

            .event-item::before {
                content: "";
                position: absolute;
                left: -10px;
                top: 0;
                bottom: 0;
                width: 3px;
                background: var(--couleur-accent);
                border-radius: 4px;
            }

            /* --------- DATE --------- */

            .event-date {
                font-size: 0.82rem;
                font-weight: 700;
                color: var(--couleur-accent);
                display: block;
                margin-bottom: 4px;
                opacity: 0.95;
            }

            /* --------- TITRE --------- */

            .event-title {
                font-size: 0.95rem;
                font-weight: 600;
                margin-bottom: 6px;
                line-height: 1.3;
            }

            /* --------- BADGE PAYS --------- */

            .event-country {
                display: inline-block;
                padding: 3px 8px;
                font-size: 0.75rem;
                border-radius: 12px;
                background: rgba(0,0,0,0.07);
                color: #333;
                font-weight: 600;
                opacity: 0.85;
                margin-top: 4px;
            }

            body.theme-sombre .event-country {
                background: rgba(255,255,255,0.08);
                color: #ddd;
            }

            /* --------- PAS D'√âV√âNEMENTS --------- */

            .events-list .no-events {
                font-size: 0.9rem;
                opacity: 0.7;
                text-align: center;
                padding: var(--espacement-sm);
            }
            
        /* Responsive */
        /* ========================================
            TIMELINE COMPARAISON DE PAYS
            ======================================== */

            .timeline-compare-wrapper {
                display: flex;
                gap: var(--espacement-lg);
                padding: var(--espacement-md) 0;
            }

            .timeline-compare-track-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: var(--espacement-sm);
            }

            .timeline-compare-track-label {
                font-size: 0.9rem;
                font-weight: 600;
                color: var(--couleur-texte);
                opacity: 0.9;
            }

            .timeline-compare-track {
                position: relative;
                height: 120px;
                overflow-x: auto;
                overflow-y: visible;
                border-bottom: 1px solid var(--couleur-bordure);
                background: var(--couleur-panneau);
                border-radius: var(--arrondi-md);
            }

            /* Conteneur interne qui s'√©tire en largeur selon la p√©riode */
            .timeline-compare-track-inner {
                position: relative;
                height: 100%;
            }

            /* Axe horizontal de la frise */
            .timeline-compare-axis {
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                height: 4px;
                background: linear-gradient(
                    90deg,
                    rgba(255, 197, 211, 0.9),
                    rgba(255, 156, 179, 0.9)
                );
                border-radius: 999px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            }

            /* Rep√®res d'ann√©es */
            .timeline-compare-year {
                position: absolute;
                top: calc(50% + 18px);
                transform: translateX(-50%);
                font-size: 0.7rem;
                font-weight: 500;
                opacity: 0.75;
            }

            /* Points d'√©v√©nements : base */
            .timeline-compare-dot {
                position: absolute;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 16px;
                height: 16px;
                background: var(--couleur-fond);
                border-radius: 50%;
                cursor: pointer;
                transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
            }

            /* Pays A : rose pastel */
            .timeline-compare-dot-A {
                border: 4px solid #FFC5D3;              /* rose pastel */
                box-shadow: 0 0 10px rgba(255, 197, 211, 0.6);
            }

            /* Pays B : bleu pastel */
            .timeline-compare-dot-B {
                border: 4px solid #C3E9FF;              /* bleu pastel */
                box-shadow: 0 0 10px rgba(195, 233, 255, 0.6);
            }

            .timeline-compare-dot:hover {
                transform: translate(-50%, -50%) scale(1.3);
            }

            /* S√©lection commune */
            .timeline-compare-dot.selected {
                transform: translate(-50%, -50%) scale(1.6);
                box-shadow: 0 0 16px rgba(0,0,0,0.25);
            }

            /* Grille pour les cartes d'√©v√©nements A / B */
            .timeline-compare-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: var(--espacement-md);
                margin-top: var(--espacement-md);
            }

            .timeline-compare-column h4 {
                margin-bottom: var(--espacement-sm);
                font-size: 0.95rem;
                color: var(--couleur-accent);

            .timeline-track.dragging {
                cursor: grabbing;
                cursor: -webkit-grabbing;
            }
            }

            /* Highlight des cartes li√©es √† la s√©lection */
            .compare-event.highlight-compare {
                outline: 2px solid var(--couleur-accent);
                box-shadow: var(--ombre-md);
                background: rgba(255, 197, 211, 0.1);
            }

            /* Vues principales : carte / studio de chronologie */
            body.view-map main {
                display: flex;
            }

            body.view-map .timeline {
                display: none;
            }

            body.view-timeline main {
                display: none;
            }

            body.view-timeline .timeline {
                display: flex;
                flex-direction: column;
                flex: 1;
                height: auto;
            }


            .main-tab {
                background: transparent;
                border: none;
                padding: 6px 12px;
                border-radius: 999px;
                cursor: pointer;
                font-size: 0.9rem;
                text-transform: lowercase;
                color: var(--couleur-texte);
                opacity: 0.7;
                transition: background var(--transition-rapide), opacity var(--transition-rapide), transform var(--transition-rapide);
            }

            .main-tab:hover {
                opacity: 1;
                transform: translateY(-1px);
            }

            .main-tab.active {
                background: var(--couleur-accent);
                color: #111827;
                opacity: 1;
            }

            /* --- Vue chronologie : r√©sum√© + mini-carte + sections par si√®cle --- */

            .timeline-section-title {
                color: var(--couleur-accent);
                margin-bottom: 0.75rem;
                font-size: 1rem;
                font-weight: 600;
            }

            .timeline-summary {
                display: grid;
                grid-template-columns: repeat(3, minmax(0, 1fr));
                gap: 0.5rem;
                padding: 0.75rem 1rem;
                margin-bottom: 0.75rem;
                border-radius: 0.75rem;
                background: var(--couleur-fond-alt);
                font-size: 0.85rem;
            }

            .timeline-inline-persons {
                margin: 0.5rem 0 0.75rem 0;
                padding: 0.5rem 0.75rem;
                border-radius: 0.75rem;
                background: var(--couleur-panneau);
                border: 1px solid var(--couleur-bordure);
            }

            .timeline-inline-persons h4 {
                font-size: 0.85rem;
                font-weight: 600;
                margin-bottom: 0.35rem;
                text-transform: lowercase;
                opacity: 0.8;
            }

            .timeline-summary-line {
                display: flex;
                flex-direction: column;
            }

            .timeline-summary .summary-label {
                opacity: 0.7;
                text-transform: uppercase;
                letter-spacing: 0.04em;
                font-size: 0.7rem;
                margin-bottom: 0.15rem;
            }

            .timeline-summary .summary-value {
                font-weight: 500;
            }

            /* mini-carte dans l'onglet chronologie */

            .timeline-mini-map {
                width: 100%;
                height: 180px;
                border-radius: 0.75rem;
                overflow: hidden;
                margin-bottom: 1rem;
                border: 1px solid rgba(0,0,0,0.05);
            }

            /* listes par si√®cle pliables */

            .timeline-century-list {
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
            }

            .timeline-century-group {
                border-radius: 0.75rem;
                border: 1px solid rgba(0,0,0,0.05);
                background: var(--couleur-fond-alt);
                overflow: hidden;
            }

            .timeline-century-header {
                padding: 0.4rem 0.75rem;
            }

            .timeline-century-toggle {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 0.5rem;
                width: 100%;
                background: transparent;
                border: none;
                font: inherit;
                cursor: pointer;
                padding: 0;
            }

            .timeline-century-toggle .century-label {
                font-weight: 600;
            }

            .timeline-century-toggle .century-count {
                font-size: 0.8rem;
                opacity: 0.7;
            }

            .timeline-century-toggle .chevron {
                font-size: 0.8rem;
                opacity: 0.7;
                transition: transform 0.15s ease-out;
            }

            .timeline-century-group.collapsed .timeline-century-events {
                display: none;
            }

            .timeline-century-group.collapsed .timeline-century-toggle .chevron {
                transform: rotate(-90deg);
            }

            .timeline-century-events {
                padding: 0.4rem 0.75rem 0.7rem 0.75rem;
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
            }

            /* cartes d‚Äô√©v√©nement dans la vue chronologie */

            .timeline-event-card {
                padding: 0.45rem 0.6rem;
                border-radius: 0.6rem;
                background: #ffffff;
                cursor: pointer;
                box-shadow: 0 1px 2px rgba(15,23,42,0.04);
                transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            }

            .theme-sombre .timeline-event-card {
                background: rgba(15,23,42,0.9);
            }

            .timeline-event-card:hover {
                transform: translateY(-1px);
                box-shadow: 0 4px 8px rgba(15,23,42,0.08);
            }

            .event-date-row {
                display: flex;
                justify-content: space-between;
                font-size: 0.8rem;
                opacity: 0.8;
                margin-bottom: 0.1rem;
            }

            .event-title-row {
                display: flex;
                align-items: center;
                gap: 0.45rem;
                font-size: 0.9rem;
                font-weight: 500;
            }

            .event-title-row .event-icon {
                font-size: 0.85rem;
            }

            .timeline-event-card .event-description {
                margin-top: 0.15rem;
                font-size: 0.8rem;
                opacity: 0.8;
            }

            @media (max-width: 768px) {
                .timeline-summary {
                    grid-template-columns: minmax(0, 1fr);
                }
            }
            
            /* On masque ces onglets en mobile */
            @media (max-width: 768px) {
                .main-tabs {
                    display: none;
                }
            }

            /* Mobile : les colonnes passent l'une sous l'autre */
            @media (max-width: 768px) {
                .timeline-compare-wrapper {
                    flex-direction: column;
                }
                
                .timeline-compare-grid {
                    grid-template-columns: 1fr;
                }
            }

            .mobile-tabs {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                height: 48px;
                background: var(--couleur-panneau);
                border-top: 1px solid var(--couleur-bordure);
                display: none; /* par d√©faut, visible seulement en mobile */
                z-index: 3000;
            }

            .mobile-tab {
                flex: 1;
                border: none;
                background: transparent;
                color: var(--couleur-texte);
                font-size: 0.8rem;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                cursor: pointer;
            }

            .mobile-tab.active {
                background: var(--couleur-accent);
                color: #111827;
            }

            /* Activation en mobile */
            @media (max-width: 768px) {
                .mobile-tabs {
                    display: flex;
                }

                /* on r√©serve un peu de place en bas pour ne pas cacher le contenu */
                body {
                    padding-bottom: 52px;
                }
            }

        
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                width: 100%;
                height: 100%;
                z-index: 2000;
            }
            
            .continent-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }

            /* Timeline moins haute en mode normal, et VRAIMENT petite en mode abaiss√©e */
            .timeline {
                height: 180px;          /* timeline d√©velopp√©e */
            }

            .timeline.collapsed {
                height: 60px;           /* barre fine quand abaiss√©e */
            }

            /* S'assurer que la carte a toujours une taille d√©cente sur mobile */
            .map-container {
                min-height: 200px;
            }

            /* Optionnel : si tu veux autoriser un peu de scroll plut√¥t que tout caser dans 100vh
            body {
                overflow: auto;
            }
            */

            /* Mode mobile "√âv√©nements" : on affiche la sidebar en plein √©cran, on masque la carte */
            body.mobile-mode-events .sidebar {
                position: relative;
                width: 100%;
                max-width: none;
                height: auto;
                transform: translateX(0); /* au cas o√π elle √©tait "collapsed" */
            }

            body.mobile-mode-events .map-container,
            body.mobile-mode-events .timeline-compare-wrapper {
                display: none;
            }
        }

        /* Popup personnalis√©e pour Leaflet */
        .leaflet-popup-content-wrapper {
            border-radius: var(--arrondi-lg) !important;
            box-shadow: var(--ombre-lg) !important;
        }

        .leaflet-popup-content {
            margin: var(--espacement-md) !important;
            line-height: 1.6 !important;
        }

        /* Indicateur de chargement */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normale);
        }

        .loading-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--couleur-bordure);
            border-top: 4px solid var(--couleur-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

                /* ============ Sidebar plus l√©g√®re ============ */

        .sidebar {
            flex: 0 0 280px;
            max-width: 280px;
            background: linear-gradient(
                180deg,
                var(--couleur-panneau) 0%,
                var(--couleur-fond) 40%
            );
        }

        .sidebar-content {
            padding: 20px 18px 28px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Titres de section : plus petits, plus discrets */
        .control-section h3 {
            margin: 0 0 6px 0;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--couleur-texte);
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Chaque section = simple s√©paration, pas de gros blocs forts */
        .control-section {
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.25);
        }

        .control-section:last-of-type {
            border-bottom: none;
        }

        /* ============ Filtres continents ============ */

        .continent-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .btn-continent {
            flex: 1 1 calc(50% - 8px);
            padding: 6px 10px;
            background: transparent;
            border-radius: 9999px;
            border: 1px solid var(--couleur-bordure);
            font-size: 0.8rem;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.15s ease, border-color 0.15s ease,
                        transform 0.1s ease, box-shadow 0.15s ease;
        }

        .btn-continent:hover {
            border-color: var(--couleur-accent);
            box-shadow: var(--ombre-sm);
            transform: translateY(-1px);
        }

        .btn-continent.active {
            background: var(--couleur-accent);
            color: #ffffff;
            border-color: var(--couleur-accent);
            box-shadow: var(--ombre-md);
        }

        /* ============ P√©riode + affichage ============ */
        .range-control {
            background: transparent;
            border-radius: 12px;
            border: 1px solid var(--couleur-bordure);
            padding: 12px 10px;
            box-shadow: none;
        }

        .range-label {
            margin-bottom: 10px;
        }

        .year-input {
            font-size: 0.85rem;
            min-width: 72px;
            padding: 4px 8px;
        }

        .range-slider {
            height: 4px;
            border-radius: 999px;
        }

        /* boutons "ann√©e courante / tout" -> look de petits onglets */
        .filter-buttons {
            display: flex;
            gap: 6px;
        }

        .btn-filter {
            flex: 1;
            padding: 6px 10px;
            font-size: 0.8rem;
            border-radius: 9999px;
            border-width: 1px;
            border-style: solid;
            border-color: var(--couleur-bordure);
            background: transparent;
            box-shadow: none;
        }

        .btn-filter.active {
            background: var(--couleur-accent);
            color: #fff;
            border-color: var(--couleur-accent);
        }

        /* ============ Liste d'√©v√©nements plus minimaliste ============ */
        .events-list {
            padding: 4px 0;
            background: transparent;
            border-radius: 0;
            border: none;
            box-shadow: none;
            max-height: 260px;
            gap: 4px;
        }

        .event-item {
            position: relative;
            background: transparent;
            border-radius: 8px;
            border: none;
            padding: 6px 4px;
            box-shadow: none;
            cursor: pointer;
            transition: background-color 0.12s ease, transform 0.08s ease;
        }

        .event-item::before {
            display: none;
        }

        .event-item:hover {
            background: rgba(148, 163, 184, 0.12);
            transform: translateY(-1px);
        }

        .event-date {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .event-title {
            font-size: 0.85rem;
            font-weight: 550;
            margin-bottom: 2px;
        }

        .event-country {
            font-size: 0.75rem;
            opacity: 0.7;
            padding: 0;
            background: transparent;
        }

        /* ============ Widget Obsidian simplifi√© ============ */

        .obsidian-section {
            background: var(--couleur-fond);
            color: var(--couleur-texte);
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid var(--couleur-bordure);
            margin-bottom: 0;
            box-shadow: none;
        }

        .obsidian-section h3 {
            color: inherit;
            margin-bottom: 6px;
        }

        .obsidian-status {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .obsidian-actions {
            display: flex;
            gap: 6px;
        }

        .btn-obsidian {
            background: transparent;
            border-radius: 9999px;
            border: 1px solid var(--couleur-bordure);
            padding: 4px 8px;
            font-size: 0.8rem;
        }

        .btn-obsidian:hover {
            background: var(--couleur-panneau);
        }


        .detail-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 4500;
            backdrop-filter: blur(6px);
        }

        .detail-overlay.open {
            display: flex;
        }

        .detail-modal {
            background: var(--couleur-panneau);
            width: calc(100vw - 4cm);   /* marge fixe autour */
            height: calc(100vh - 4cm);  /* marge fixe haut/bas */
            border-radius: 24px;
            box-shadow: var(--ombre-lg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .detail-header {
            padding: 10px 16px;
            border-bottom: 1px solid var(--couleur-bordure);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: var(--couleur-panneau);
        }

        .detail-title {
            font-size: 1.1rem;
            font-weight: 600;
            text-transform: none;
        }

        .detail-subtitle {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .detail-close {
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1.1rem;
            padding: 4px 8px;
            border-radius: 999px;
        }

        .detail-close:hover {
            background: rgba(148, 163, 184, 0.25);
        }

        .detail-body {
            padding: 12px 16px 16px;
            overflow-y: auto;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .detail-main {
            display: grid;
            grid-template-columns: 2.2fr 3fr; /* un peu plus de place aux stats */
            gap: 12px;
        }

        .detail-map {
            height: 240px; /* au lieu de 200px : plus lisible */
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--couleur-bordure);
        }


        .detail-stats {
            border-radius: 12px;
            border: 1px solid var(--couleur-bordure);
            padding: 8px 10px;
            background: var(--couleur-panneau);
        }

        .detail-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px 10px;
        }

        .detail-stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            opacity: 0.7;
        }

        .detail-stat-value {
            font-size: 0.9rem;
        }

        .detail-section h3 {
            font-size: 0.85rem;
            text-transform: lowercase;
            margin-bottom: 4px;
            opacity: 0.8;
        }

        .detail-timeline-item {
            padding: 4px 0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.3);
            font-size: 0.88rem;
        }

        .detail-timeline-item strong {
            color: var(--couleur-accent);
        }

        .detail-persons-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .detail-person-chip {
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.7);
            font-size: 0.78rem;
            cursor: pointer;
        }

        

        .detail-person-chip:hover {
            background: rgba(148, 163, 184, 0.15);
        }

        /* Titres de sections dans les fiches (pays, personnages, etc.) */
        .detail-section h3 {
            font-size: 0.82rem;
            text-transform: lowercase;
            letter-spacing: 0.12em;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .detail-section + .detail-section {
            border-top: 1px solid rgba(148, 163, 184, 0.25);
            padding-top: 8px;
        }

        /* Titre cliquable qui ouvre l'index des √©v√©nements */
        .detail-section-title-clickable {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .detail-section-title-clickable::after {
            content: "‚Üó";
            font-size: 0.7rem;
            opacity: 0.6;
        }

        .detail-section-title-clickable:hover {
            opacity: 1;
            text-decoration: underline;
        }

        /* Scroll interne pour la chrono condens√©e et les personnages */
        .detail-timeline-scroll,
        .detail-persons-scroll {
            max-height: 180px;
            overflow-y: auto;
            padding-right: 4px;
            margin-top: 4px;
        }

        /* √âv√©nements cliquables dans la fiche pays */
        .detail-timeline-item {
            width: 100%;
            display: flex;
            align-items: baseline;
            gap: 6px;
            padding: 4px 6px;
            border-radius: 8px;
            border: none;
            background: transparent;
            font-size: 0.86rem;
            cursor: pointer;
            text-align: left;
        }

        .detail-timeline-item + .detail-timeline-item {
            margin-top: 2px;
            border-top: 1px solid rgba(148, 163, 184, 0.2);
        }

        .detail-timeline-item:hover {
            background: rgba(148, 163, 184, 0.12);
        }

        .detail-timeline-date {
            font-weight: 600;
            color: var(--couleur-accent);
            white-space: nowrap;
            font-size: 0.8rem;
        }

        .detail-timeline-separator {
            opacity: 0.7;
        }

        .detail-timeline-title {
            flex: 1;
        }

        /* Liste de personnages dans la fiche pays : scrollable */
        .detail-persons-scroll {
            max-height: 160px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .detail-persons-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .detail-person-chip {
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.7);
            font-size: 0.78rem;
            cursor: pointer;
            background: rgba(15, 23, 42, 0.02);
        }

        .detail-person-chip:hover {
            background: rgba(148, 163, 184, 0.18);
        }

        @media (max-width: 768px) {
            .detail-modal {
                width: 96vw;
                max-height: 90vh;
                border-radius: 14px;
            }
            .detail-main {
                grid-template-columns: 1fr;
            }
            .detail-map {
                height: 180px;
            }

            /* Popup fiche pays / personnage : plein √©cran avec marges */
            .detail-overlay {
                position: fixed;
                inset: 0;
                background: rgba(15, 23, 42, 0.55);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            }

            .detail-overlay.open {
                display: flex;
            }

            .detail-header {
                padding: var(--espacement-md) var(--espacement-lg);
                border-bottom: 1px solid var(--couleur-bordure);
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: var(--espacement-md);
            }

            .detail-body {
                padding: 12px 16px 16px;
                font-size: 0.9rem;
                display: flex;
                flex-direction: column;
                gap: 12px;
                flex: 1;            /* occupe toute la hauteur de la modal */
                overflow: hidden;   /* le scroll se fait dans les blocs internes */
            }


            /* Carte + stats */
            .detail-main {
                display: grid;
                grid-template-columns: minmax(0, 1.3fr) minmax(0, 1fr);
                gap: var(--espacement-md);
                min-height: 0;
            }

            .detail-map {
                background: var(--couleur-fond);
                border-radius: var(--arrondi-lg);
                overflow: hidden;
                min-height: 0;
            }

            .detail-stats {
                background: var(--couleur-fond);
                border-radius: var(--arrondi-lg);
                padding: var(--espacement-md);
                overflow: auto;
                min-height: 0;
            }

            /* Sections (bio, chronologie, pays) : chacune scrollable si besoin */
            .detail-section {
                background: var(--couleur-fond);
                border-radius: var(--arrondi-lg);
                padding: var(--espacement-md);
                min-height: 0;
                max-height: 35vh;      /* chaque bloc peut scroller */
                overflow: auto;
            }

            /* bio particuli√®rement scrollable */
            .detail-main {
                display: grid;
                grid-template-columns: 2.2fr 3fr;
                gap: 12px;
                min-height: 0;
            }

            /* chaque section peut scroller si elle est tr√®s longue */
            .detail-section {
                min-height: 0;
                max-height: 38vh;
                overflow-y: auto;
            }
            
            /* style de la bio longue */
            .person-bio {
                white-space: pre-wrap;
                line-height: 1.5;
            }

            .md-content h1 {
                font-size: 1.8rem;
                margin: 1rem 0;
                font-weight: 700;
            }

            .md-content h2 {
                font-size: 1.45rem;
                margin: 1rem 0 0.5rem;
                font-weight: 600;
            }

            .md-content h3 {
                font-size: 1.2rem;
                margin: 0.8rem 0 0.4rem;
                font-weight: 600;
            }

            .md-content p {
                margin: 0.5rem 0;
                line-height: 1.55;
            }

            .md-content ul,
            .md-content ol {
                margin: 0.5rem 0 0.5rem 1.2rem;
            }

            .md-content strong {
                font-weight: 600;
            }
        }

        /* ============================
        POPUP ANNUAIRE (√©v√©nements / personnages)
        ============================ */

        .link-title {
            all: unset;
            cursor: pointer;
            font: inherit;
            color: inherit;
        }

        .link-title:hover {
            color: var(--couleur-accent);
        }

        .directory-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            backdrop-filter: blur(6px);
        }

        .directory-overlay.open {
            display: flex;
        }

        .directory-modal {
            background: var(--couleur-fond);
            color: var(--couleur-texte);
            width: min(900px, 95vw);
            max-height: 80vh;
            border-radius: 18px;
            box-shadow: var(--ombre-lg);
            display: flex;
            flex-direction: column;
            border: 1px solid var(--couleur-bordure);
            overflow: hidden;
        }

        .directory-header {
            padding: 10px 14px;
            border-bottom: 1px solid var(--couleur-bordure);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: var(--couleur-panneau);
        }

        .directory-title {
            font-size: 0.95rem;
            font-weight: 600;
            text-transform: lowercase;
        }

        .directory-close {
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1.1rem;
            padding: 4px 8px;
            border-radius: 999px;
            transition: background 0.15s ease;
        }

        .directory-close:hover {
            background: rgba(148, 163, 184, 0.25);
        }

        .directory-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            font-size: 0.9rem;
        }

        .directory-section {
            margin-bottom: 10px;
        }

        .directory-letter {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--couleur-texte);
            opacity: 0.7;
            padding: 6px 4px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.35);
            margin-bottom: 4px;
        }

        .directory-list {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .directory-item {
            padding: 5px 4px;
            border-radius: 8px;
            transition: background 0.12s ease, transform 0.08s ease;
        }

        .directory-item:hover {
            background: rgba(148, 163, 184, 0.12);
            transform: translateY(-1px);
        }

        .directory-item-title {
            font-weight: 550;
            font-size: 0.9rem;
            text-align: left;
            border: none;
            background: transparent;
            padding: 0;
            margin: 0;
            cursor: pointer;
        }

        .directory-item-title-link {
            color: inherit;
            text-decoration: none;
        }

        .directory-item-title-link:hover {
            text-decoration: underline;
        }

        .directory-item-meta {
            margin-top: 2px;
            font-size: 0.78rem;
            opacity: 0.75;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .directory-chip {
            padding: 1px 6px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.5);
        }

        @media (max-width: 768px) {
            .directory-modal {
                width: 94vw;
                max-height: 85vh;
                border-radius: 14px;
            }
        }

        /* ===== AFFICHAGE "STUDIO" EN VUE CHRONOLOGIE (FRISE EN HAUT) ===== */

        body.view-timeline .timeline {
            /* la timeline occupe quasi tout l'√©cran sous le header */
            height: calc(100vh - 64px);
            max-height: calc(100vh - 64px);
            margin: 8px 12px 0;
            border-radius: 18px 18px 0 0;
            background: var(--couleur-fond);
            box-shadow: 0 -4px 20px rgba(15, 23, 42, 0.12);
            overflow: hidden;
        }

        /* on remplace le grid par une simple colonne :
        1) frise en haut  (‚âà 1/3)
        2) liste en bas   (‚âà 2/3) */
        body.view-timeline .timeline-country,
        body.view-timeline .timeline-global {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 18px;
            padding: 14px 24px 18px;
        }

        /* bloc frise : 1/3 de la hauteur */
        body.view-timeline .timeline-nav {
            flex: 0 0 32vh;        /* ~ un tiers de la fen√™tre */
            max-height: 260px;
            min-height: 160px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* piste de la frise : carte "propre" et bien contenue */
        body.view-timeline .timeline-nav .timeline-track {
            flex: 1;
            border-radius: 14px;
            background: var(--couleur-panneau);
            border: 1px solid var(--couleur-bordure);
            box-shadow: var(--ombre-sm);
            padding: 6px 0;
        }

        /* bouton ‚óÄ ‚ñ∂ discrets */
        body.view-timeline .timeline-arrow {
            width: 30px;
            height: 30px;
            font-size: 0.9rem;
        }

        /* frise + rep√®res un peu plus sobres */
        body.view-timeline .timeline-axis {
            height: 4px;
            background: linear-gradient(
                90deg,
                rgba(255, 197, 211, 0.9),
                rgba(209, 213, 219, 0.9)
            );
            border-radius: 999px;
        }

        body.view-timeline .timeline-year {
            font-size: 0.7rem;
            opacity: 0.65;
        }

        /* points d'√©v√©nements l√©g√®rement r√©duits */
        body.view-timeline .timeline-dot {
            width: 14px;
            height: 14px;
            border-width: 3px;
        }

        /* bloc liste : occupe le reste et est centr√© */
        body.view-timeline .timeline-content,
        body.view-timeline #timeline-global-content {
            flex: 1;
            max-height: none;
            width: 100%;
            max-width: 1100px;     /* largeur confortable pour la lecture */
            margin: 0 auto 8px;
            background: var(--couleur-panneau);
            border-radius: 14px;
            border: 1px solid var(--couleur-bordure);
            padding: 10px 12px 14px;
            overflow-y: auto;
        }

        /* cartes d'√©v√®nements un peu resserr√©es */
        body.view-timeline .timeline-event {
            margin-bottom: 8px;
            padding: 8px 8px;
            border-radius: 10px;
            border-left-width: 3px;
            box-shadow: none;
        }

        body.view-timeline .timeline-event:hover {
            transform: translateX(2px);
            box-shadow: var(--ombre-sm);
        }
        /* ====== STUDIO CHRONOLOGIE ‚Äî TIMELINE LARGE, HAUTE ET ALIGN√âE ====== */

        body.view-timeline .timeline {
            height: calc(100vh - 64px);
            margin: 8px auto 0;
            padding: 0;
            max-width: 1100px;
            border-radius: 18px 18px 0 0;
            background: var(--couleur-fond);
            box-shadow: 0 -4px 20px rgba(15, 23, 42, 0.12);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Studio : timeline en haut (‚âà 45% viewport) + liste d'√©v√©nements en bas (‚âà 55%) */
        body.view-timeline .timeline-country,
        body.view-timeline .timeline-global {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 20px 18px;
            gap: 20px;
        }

        /* --- FR I S E --- */
        /* La frise fait maintenant ~45% de la hauteur du studio */
        body.view-timeline .timeline-nav {
            flex: 0 0 45vh; /* <-- triple hauteur par rapport √† l'ancien layout */
            display: flex;
            align-items: center;
            gap: 14px;
        }

        /* La piste de la frise adopte les m√™mes dimensions visuelles que la liste */
        body.view-timeline .timeline-track {
            flex: 1;
            height: 100%;
            border-radius: 14px;
            background: var(--couleur-panneau);
            border: 1px solid var(--couleur-bordure);
            box-shadow: var(--ombre-sm);
            padding: 10px 0;
            max-width: 1100px;
            margin: 0 auto;
        }

        /* Ligne de fond de la frise */
        body.view-timeline .timeline-axis {
            height: 5px;
            background: linear-gradient(
                90deg,
                rgba(255, 197, 211, 0.9),
                rgba(209, 213, 219, 0.9)
            );
            border-radius: 999px;
        }

        /* Rep√®res d'ann√©es */
        body.view-timeline .timeline-year {
            font-size: 0.75rem;
            opacity: 0.65;
        }

        /* Points d'√©v√©nements */
        body.view-timeline .timeline-dot {
            width: 16px;
            height: 16px;
            border-width: 3px;
            box-shadow: 0 0 8px rgba(15, 23, 42, 0.25);
        }

        body.view-timeline .timeline-dot.selected {
            transform: translate(-50%, -50%) scale(1.4);
        }

        /* --- LISTE D'√âV√âNEMENTS (m√™me largeur visuelle que la frise) --- */
        body.view-timeline .timeline-content,
        body.view-timeline #timeline-global-content {
            flex: 1;
            max-height: none;
            max-width: 1100px;
            margin: 0 auto;
            background: var(--couleur-panneau);
            border-radius: 14px;
            border: 1px solid var(--couleur-bordure);
            padding: 14px 16px;
            overflow-y: auto;
        }

        /* Cartes d‚Äô√©v√©nements compactes & lisibles */
        body.view-timeline .timeline-event {
            margin-bottom: 10px;
            padding: 10px 10px;
            border-radius: 12px;
            border-left: 3px solid var(--couleur-accent);
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(3px);
        }

        body.view-timeline .timeline-event:hover {
            transform: translateX(2px);
            box-shadow: var(--ombre-sm);
        }

        /* ===== CORRECTION SCROLL POUR LA VUE CHRONOLOGIE ===== */

        /* Le conteneur principal doit pouvoir scroller si le contenu d√©passe */
        body.view-timeline .timeline {
            height: calc(100vh - 64px);
            max-height: calc(100vh - 64px);
            margin: 8px auto 0;
            padding: 0;
            max-width: 1100px;
            border-radius: 18px 18px 0 0;
            background: var(--couleur-fond);
            box-shadow: 0 -4px 20px rgba(15, 23, 42, 0.12);

            /* FIX : permettre le scroll vertical */
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Plus de overflow:hidden dans les blocs internes */
        body.view-timeline .timeline-country,
        body.view-timeline .timeline-global {
            display: flex;
            flex-direction: column;
            gap: 18px;
            padding: 14px 24px 18px;

            /* FIX : retirer overflow:hidden */
            overflow: visible;
        }

        /* FIX : la frise a une hauteur fixe (‚âà 40% √©cran) */
        body.view-timeline .timeline-nav {
            flex: 0 0 40vh;
            min-height: 220px;
            max-height: 380px;
        }

        /* FIX : liste d‚Äô√©v√®nements scrolle correctement */
        body.view-timeline .timeline-content,
        body.view-timeline #timeline-global-content {
            flex: 1;
            max-width: 1100px;
            margin: 0 auto 12px;
            background: var(--couleur-panneau);
            border-radius: 14px;
            border: 1px solid var(--couleur-bordure);
            padding: 14px 16px;

            /* IMPORTANT : scroll interne */
            overflow-y: auto;
        }

        /* petites ajustements pour √©viter que la page enti√®re bloque le scroll */
        html, body {
            overscroll-behavior: contain;
        }

        /* ==============================
        VERSION "FULL-WIDTH" des barres chrono
        ============================== */

        body.view-timeline .timeline-header {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 14px 18px;
            border-bottom: 1px solid var(--couleur-bordure);
            background: radial-gradient(circle at top left,
                rgba(255, 197, 211, 0.14),
                transparent 55%
            );
        }

        /* Bloc gauche = titre + sous-texte */
        body.view-timeline .timeline-header-left {
            width: 100%;
        }

        body.view-timeline .timeline-header-left h2 {
            font-size: 1.08rem;
            margin-bottom: 4px;
        }

        body.view-timeline .timeline-header-left .detail-subtitle {
            opacity: 0.7;
            font-size: 0.8rem;
        }

        /* Bloc droit = onglets + filtres empil√©s mais FULL WIDTH */
        body.view-timeline .timeline-header-right {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ======= BARRE 1 : Onglets pleine largeur ======= */
        body.view-timeline .timeline-tabs {
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 6px 8px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.06);
            backdrop-filter: blur(10px);
            border: 1px solid var(--couleur-bordure);
        }

        body.view-timeline .timeline-tabs .btn {
            flex: 1;
            text-align: center;
            padding: 8px 0;
            font-size: 0.8rem;
            border-radius: 10px;
            transition: 0.15s;
        }

        body.view-timeline .timeline-tabs .btn.active {
            background: var(--couleur-accent);
            color: var(--couleur-texte-sombre);
            box-shadow: 0 1px 4px rgba(15, 23, 42, 0.25);
        }

        /* petit espace entre les onglets */
        body.view-timeline .timeline-tabs .btn + .btn {
            margin-left: 6px;
        }

        /* ======= BARRE 2 : Filtres pleine largeur ======= */
        body.view-timeline .timeline-header-controls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.05);
            border: 1px solid var(--couleur-bordure);
        }

        body.view-timeline .timeline-header-controls select,
        body.view-timeline .timeline-header-controls input {
            flex: 1;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 0.8rem;
            background: rgba(15, 23, 42, 0.03);
        }

        /* Range inputs (de ‚Üí √†) dans une cellule flexible */
        body.view-timeline .timeline-range-inputs {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        body.view-timeline .timeline-range-inputs span {
            opacity: 0.55;
        }

        /* Mobile */
        @media (max-width: 768px) {
            body.view-timeline .timeline-header-controls {
                flex-direction: column;
                gap: 6px;
            }
        }

        #detail-panel {
            max-width: calc(100% - 4rem);  /* ‚âà 2rem de marge de chaque c√¥t√© */
            margin: 2rem auto;
            height: calc(100% - 4rem);
            display: flex;
            flex-direction: column;
        }

        .detail-body {
            display: grid;
            grid-template-columns: 1.1fr 1fr;
            gap: 1.5rem;
            height: calc(100% - 60px); /* en gros, sous le header de la fiche */
            overflow: hidden;
        }

        .detail-section {
            overflow-y: auto;
        }

        body.view-notes .sidebar,
        body.view-notes .map-container,
        body.view-notes .timeline {
            display: none;
        }

        body.view-notes .notes-panel {
            display: block;
        }
    </style>
</head>
<body class="view-map mobile-mode-map">
    <!-- Overlay de chargement -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

    <!-- Header avec indicateur de sync -->
    <header>
        <div class="logo">
            <h1>carte.</h1>
            <div class="sync-indicator" id="sync-indicator">
                <div class="sync-dot"></div>
                <span>Synchronis√©</span>
            </div>
        </div>

        <!-- Onglets desktop : carte / chronologie -->
        <nav class="main-tabs" id="desktop-tabs">
            <button class="main-tab active" data-main-view="map">
                carte.
            </button>
            <button class="main-tab" data-main-view="timeline">
                chronologie.
            </button>
            <button class="main-tab" data-main-view="notes">
                notes.
            </button>
        </nav>

        <!-- Barre de recherche globale -->
        <div class="global-search" id="global-search">
            <input
                type="search"
                id="global-search-input"
                class="global-search-input"
                placeholder="Rechercher un √©v√®nement ou un personnage‚Ä¶"
                autocomplete="off"
                spellcheck="false"
            >
            <div id="global-search-results" class="global-search-results"></div>
        </div>

        <div class="header-controls">
            <button id="refresh-btn" class="btn btn-secondary" title="Actualiser les donn√©es">
                üîÑ
            </button>
            <button id="export-btn" class="btn btn-secondary" title="Exporter les donn√©es">
                üìÅ
            </button>
            <button id="theme-btn" class="btn" title="Changer le th√®me">
                üåì
            </button>
        </div>
    </header>

    <!-- Contenu principal -->
    <main>
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-content">

                <!-- Vue principale de la sidebar -->
                <div id="sidebar-main">
                    <!-- Continents -->
                    <section class="control-section">
                        <h3>continents.</h3>
                        <div class="continent-grid" role="group" aria-label="Filtres par continent">
                            <button class="btn-continent active" data-continent="tous">üåç Tous</button>
                            <button class="btn-continent" data-continent="europe">üåè Europe</button>
                            <button class="btn-continent" data-continent="asie">üåè Asie</button>
                            <button class="btn-continent" data-continent="afrique">üåç Afrique</button>
                            <button class="btn-continent" data-continent="amerique">üåé Am√©rique</button>
                            <button class="btn-continent" data-continent="oceanie">üåè Oc√©anie</button>
                        </div>
                    </section>

                    <!-- Filtre ann√©e -->
                    <section class="control-section">
                        <h3>p√©riode.</h3>
                        <div class="range-control">
                            <div class="range-label">
                                <input type="number" 
                                    id="input-annee" 
                                    class="year-input"
                                    min="-500" 
                                    max="2024" 
                                    value="2024"
                                    placeholder="Tapez une ann√©e">
                            </div>
                            <input type="range" 
                                id="slider-annee" 
                                class="range-slider"
                                min="-2000" 
                                max="2024" 
                                value="2024"
                                aria-label="S√©lecteur d'ann√©e">
                        </div>
                        <h3>.</h3>
                        <div class="filter-buttons">
                            <button class="btn-filter" data-filter="all">tout.</button>
                            <button class="btn-filter active" data-filter="year">ann√©e courante.</button>
                        </div>
                    </section>

                    <!-- Liste des √©v√©nements de l'ann√©e -->
                    <section class="control-section">
                        <h3>
                            <button type="button" class="link-title" id="open-events-directory">
                                tous les √©v√©nements.
                            </button>
                        </h3>
                        <div class="events-list" id="events-list">
                            <p class="no-events">Aucun √©v√©nement.</p>
                        </div>
                    </section>

                    <!-- Liste des personnages -->
                    <section class="control-section">
                        <h3>
                            <button type="button" class="link-title" id="open-persons-directory">
                                tous les personnages.
                            </button>
                        </h3>
                        <div class="events-list" id="persons-list">
                            <p class="no-events">Aucun personnage r√©f√©renc√©.</p>
                        </div>
                    </section>

                    <!-- Liste des pays -->
                    <section class="control-section">
                        <h3>
                            <button type="button" class="link-title" id="open-countries-directory">
                                tous les pays.
                            </button>
                        </h3>
                        <div class="events-list" id="countries-list">
                            <p class="no-events">Aucun pays r√©f√©renc√©.</p>
                        </div>
                    </section>

                    <!-- Comparaison de pays -->
                    <section class="control-section" id="compare-section">
                        <h3>comparer deux pays !</h3>
                        
                        <div class="compare-fields">
                            <label for="compare-country-a">1er pays</label>
                            <select id="compare-country-a">
                                <option value="">s√©lectionner un pays‚Ä¶</option>
                                <!-- options remplies en JS -->
                            </select>

                            <label for="compare-country-b">2e pays</label>
                            <select id="compare-country-b">
                                <option value="">s√©lectionner un pays‚Ä¶</option>
                                <!-- options remplies en JS -->
                            </select>

                            <div class="compare-buttons">
                                <button class="btn btn-secondary" id="compare-btn" type="button">
                                    comparer.
                                </button>
                                <button class="btn btn-secondary" id="compare-reset-btn" type="button">
                                    ‚úñ r√©initialiser.
                                </button>
                            </div>
                        </div>
                    </section>

                    <!-- Section Obsidian -->
                    <section class="obsidian-section">
                        <h3>obsidian</h3>
                        <div class="obsidian-status">
                            <span>Derni√®re sync:</span>
                            <span id="last-sync">Jamais</span>
                        </div>
                        <div class="obsidian-actions">
                            <button class="btn btn-obsidian" id="sync-now" title="Synchroniser maintenant">
                                üîÑ
                            </button>
                            <button class="btn btn-obsidian" id="watch-toggle" title="Activer/d√©sactiver la surveillance">
                                üëÅÔ∏è
                            </button>
                        </div>
                    </section>
                </div>

                <!-- Vue fiche pays (remplie en JS) -->
                <div id="sidebar-detail" style="display:none;"></div>
            </div>
        </aside>

        <!-- Zone carte -->
        <section class="map-container">
            <button class="toggle-sidebar" id="toggle-sidebar" title="Afficher/Masquer le panneau">
                ‚ò∞
            </button>
            <div id="carte"></div>
        </section>

        <!-- Vue notes -->
        <section class="notes-panel" id="notes-panel">
            <div class="notes-header">
                <div>
                    <h2>notes.</h2>
                    <p style="opacity:0.7;">Toutes les notes Obsidian, m√™me sans coordonn√©e.</p>
                </div>
                <button class="btn btn-secondary" id="open-notes-directory-main">annuaire des notes</button>
            </div>
            <div class="notes-grid" id="notes-tab-list"></div>
        </section>
    </main>

    <!-- Timeline -->
    <footer class="timeline collapsed" id="timeline">
        <div class="timeline-header">
            <div class="timeline-header-left">
                <h2>timeline.</h2>
            </div>

            <div class="timeline-header-right">
                <!-- Onglets de mode -->
                <div class="timeline-tabs" id="timeline-tabs">
                    <button class="btn btn-secondary timeline-tab" data-mode="world">
                        timeline mondiale
                    </button>
                    <button class="btn btn-secondary timeline-tab active" data-mode="country">
                        timeline du pays
                    </button>
                    <button class="btn btn-secondary timeline-tab" data-mode="person">
                        timeline personnage
                    </button>
                </div>

                <!-- Contr√¥les du studio -->
                <div class="timeline-header-controls">
                    <select id="timeline-country-select">
                        <option value="">pays‚Ä¶</option>
                    </select>

                    <select id="timeline-person-select">
                        <option value="">personnage‚Ä¶</option>
                    </select>

                    <div class="timeline-range-inputs">
                        <input type="number" id="timeline-from-year" placeholder="de" style="width: 70px;">
                        <span>‚Üí</span>
                        <input type="number" id="timeline-to-year" placeholder="√†" style="width: 70px;">
                    </div>

                    <!-- Bouton collapse gard√© pour la vue carte (cach√© en studio) -->
                    <button class="btn btn-secondary" id="toggle-timeline" title="R√©duire/√âtendre">
                        ‚ñ≤
                    </button>
                </div>
            </div>
        </div>

        <!-- TIMELINE PAYS (ton bloc existant, juste envelopp√©) -->
        <div class="timeline-country" id="timeline-country">
            <!-- Navigation + frise horizontale -->
            <div class="timeline-nav">
                <button class="timeline-arrow" id="timeline-prev" title="√âv√©nement pr√©c√©dent">‚óÄ</button>

                <div class="timeline-track" id="timeline-track">
                    <!-- rempli en JS -->
                </div>

                <button class="timeline-arrow" id="timeline-next" title="√âv√©nement suivant">‚ñ∂</button>
            </div>

            <!-- Liste des √©v√©nements du pays -->
            <div class="timeline-content" id="timeline-content">
                <p>Cliquez sur un pays pour voir sa timeline...</p>
            </div>
        </div>

        <!-- TIMELINE MONDIALE (nouveau bloc, cach√© au d√©but) -->
        <div class="timeline-global" id="timeline-global" style="display: none;">
            <div class="timeline-nav">
                <button class="timeline-arrow" id="timeline-global-prev" title="√âv√©nement pr√©c√©dent">‚óÄ</button>

                <div class="timeline-track" id="timeline-global-track">
                    <!-- sera rempli en JS avec tous les √©v√©nements -->
                </div>

                <button class="timeline-arrow" id="timeline-global-next" title="√âv√©nement suivant">‚ñ∂</button>
            </div>

            <div class="timeline-content" id="timeline-global-content">
                <p>Chronologie mondiale de tous les √©v√©nements...</p>
            </div>
        </div>
    </footer>

        <!-- Onglets mobile en bas -->
    <nav class="mobile-tabs" id="mobile-tabs">
        <button class="mobile-tab active" data-mobile-view="map">
            üó∫ carte
        </button>
        <button class="mobile-tab" data-mobile-view="events">
            üìú √©v√©nements
        </button>
        <button class="mobile-tab" data-mobile-view="timeline">
            ‚è± chronologie
        </button>
        <button class="mobile-tab" data-mobile-view="notes">
            üóíÔ∏è notes
        </button>
    </nav>

    <!-- Popup annuaire (√©v√©nements / personnages) -->
    <div class="directory-overlay" id="directory-overlay">
        <div class="directory-modal">
            <header class="directory-header">
                <h2 class="directory-title" id="directory-title"></h2>
                <button type="button" class="directory-close" id="directory-close" aria-label="Fermer">
                    ‚úï
                </button>
            </header>
            <div class="directory-content" id="directory-content">
                <!-- contenu rempli en JS -->
            </div>
        </div>
    </div>

    <!-- Popup fiche pays / personnage -->
    <div class="detail-overlay" id="detail-overlay">
        <div class="detail-modal">
            <header class="detail-header">
                <div>
                    <h2 class="detail-title" id="detail-title"></h2>
                    <p class="detail-subtitle" id="detail-subtitle"></p>
                </div>
                <button type="button" class="detail-close" id="detail-close" aria-label="Fermer">
                    ‚úï
                </button>
            </header>

            <div class="detail-body">
                <div class="detail-main">
                    <div id="detail-map" class="detail-map"></div>
                    <div id="detail-stats" class="detail-stats"></div>
                </div>

                <section class="detail-section" id="detail-bio-section" style="display:none;">
                    <h3>biographie.</h3>
                    <div id="detail-bio"></div>
                </section>
                
                <section class="detail-section" id="detail-timeline-section">
                    <h3>chronologie condens√©e.</h3>
                    <div id="detail-timeline"></div>
                </section>



                <section class="detail-section" id="detail-persons-section">
                    <h3 id="detail-persons-title">personnages majeurs.</h3>
                    <div id="detail-persons"></div>
                </section>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // ========================================
        // CLASSE PRINCIPALE AVEC SYNC OBSIDIAN
        // ========================================
        
        class HistoricalMapWithSync {
            constructor() {
                this.map = null;
                this.markers = null;
                this.selectedYear = 2024;
                this.selectedContinent = "tous";
                this.eventDisplayMode = "all"; // "year" ou "all"
                this.isDarkTheme = localStorage.getItem('theme-sombre') === 'true';
                this.isLoading = false;
                this.watchMode = false;
                this.timelineScaleMode = "auto"; // "auto" ou "fixed"
                this.timelineFixedPxPerYear = 4; // utilis√© seulement si mode "fixed"
                this.timelineDots = [];
                this.selectedTimelineIndex = null;
                this.mainView = 'map';        // 'map' ou 'timeline'
                this.mobileMode = 'map';      // 'map' | 'events' | 'timeline'
                this.currentTimelineEvents = [];
                this.compareMode = false;
                this.countryA = null;
                this.countryB = null;
                this.compareEventsA = [];
                this.compareEventsB = [];
                this.compareDotsA = [];
                this.compareDotsB = [];
                this.selectedComparisonSide = null;
                this.selectedComparisonIndex = null;
                this.timelineGlobalDots = [];
                this.currentGlobalTimelineEvents = [];
                this.selectedGlobalTimelineIndex = null;
                this.personIndex = {};              // index personnages -> { nom, events: [...] }
                this.currentTimelineContext = null; // { type: 'country' | 'person', name: string }
                this.detailMap = null;              // mini-carte dans la fiche
                this.sidebarCountryMap = null;

                // Cache et donn√©es
                this.cache = {
                    countries: [],
                    events: [],
                    persons: [],
                    notes: [],
                    lastSync: null
                };
                
                // URLs des donn√©es (adaptez selon votre structure)
                this.dataUrls = {
                    events: 'data/evenements.json',
                    countries: 'data/pays.json',
                    persons: 'data/personnes.json',
                    notes: 'data/notes.json'
                };

                
                this.init();

                // Zoom de la timeline par pays
                this.timelineZoom = 1;        // 1 = 1000 ans visibles par d√©faut
                this.timelineMinZoom = 0.5;   // d√©-zoom max (2000 ans visibles)
                this.timelineMaxZoom = 5;     // zoom max (200 ans visibles)

                // Zoom de la timeline mondiale
                this.timelineGlobalZoom = 1;        // 1 = ~1000 ans visibles
                this.timelineGlobalMinZoom = 0.5;   // d√©-zoom max (plus d'ann√©es)
                this.timelineGlobalMaxZoom = 5;     // zoom max (moins d'ann√©es)

                this.timelineMiniMap = null;
                this.timelineMiniLayer = null;
            }
            
            async init() {
                console.log("üöÄ Initialisation avec synchronisation Obsidian");
                
                // Appliquer le th√®me
                if (this.isDarkTheme) {
                    document.body.classList.add('theme-sombre');
                }
                
                // Initialiser les composants
                this.initMap();
                this.initControls();
                this.initObsidianSync();
                
                // Charger les donn√©es
                await this.loadData();
                this.updateDisplay();
                // Vue par d√©faut
                this.setMainView('map');
                this.setMobileMode('map');

                
                console.log("‚úÖ Carte avec sync Obsidian initialis√©e");
            }
            
            initMap() {
                this.map = L.map('carte', {
                    center: [25, 10],        // centre un peu plus haut et d√©cal√© (Europe / Afrique / Moyen-Orient)
                    zoom: 3,                 // au lieu de 2 -> plus zoom√© d√®s l'arriv√©e
                    minZoom: 3,              // tu ne peux plus d√©zoomer en dessous (plus de ¬´ monde minuscule ¬ª)
                    maxZoom: 18,
                    maxBounds: [[-85, -180], [85, 180]], // emp√™che de sortir du monde
                    maxBoundsViscosity: 1.0,             // effet ¬´ rebond ¬ª aux bords
                    worldCopyJump: true,
                    zoomControl: false
                });

                L.control.zoom({
                    position: 'bottomright'
                }).addTo(this.map);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 18
                }).addTo(this.map);

                this.markers = L.layerGroup().addTo(this.map);

                setTimeout(() => {
                    if (this.map) this.map.invalidateSize();
                }, 0);
            }
            
            initControls() {
                // R√©f√©rences pour la popup annuaire
                this.directoryOverlay = document.getElementById('directory-overlay');
                this.directoryTitleElem = document.getElementById('directory-title');
                this.directoryContentElem = document.getElementById('directory-content');
                
                // Contr√¥les de base
                document.getElementById('theme-btn').addEventListener('click', () => {
                    this.toggleTheme();
                });

                // üîé Barre de recherche globale (√©v√©nements + personnages)
                const searchInput   = document.getElementById('global-search-input');
                const searchResults = document.getElementById('global-search-results');

                if (searchInput && searchResults) {
                    // Saisie : lancer la recherche √† partir de 2 caract√®res
                    searchInput.addEventListener('input', (e) => {
                        const value = (e.target.value || '').trim();
                        if (value.length < 2) {
                            searchResults.innerHTML = '';
                            searchResults.classList.remove('open');
                            return;
                        }
                        this.updateGlobalSearchResults(value);
                    });

                    // Focus : si d√©j√† des r√©sultats pour la valeur courante, on les r√©affiche
                    searchInput.addEventListener('focus', () => {
                        const value = (searchInput.value || '').trim();
                        if (value.length >= 2 && searchResults.innerHTML.trim() !== '') {
                            searchResults.classList.add('open');
                        }
                    });

                    // √âchap pour nettoyer / fermer
                    searchInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            searchInput.value = '';
                            searchResults.innerHTML = '';
                            searchResults.classList.remove('open');
                            searchInput.blur();
                        }
                    });

                    // Fermeture si clic en dehors
                    document.addEventListener('click', (e) => {
                        const wrapper = document.getElementById('global-search');
                        if (!wrapper) return;
                        if (!wrapper.contains(e.target)) {
                            searchResults.innerHTML = '';
                            searchResults.classList.remove('open');
                        }
                    });
                }

                // Onglets desktop carte / chronologie
                const mainTabs = document.querySelectorAll('.main-tab');
                mainTabs.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const view = btn.dataset.mainView || 'map';
                        this.setMainView(view);

                        // Si on passe en vue "chronologie", on affiche automatiquement la timeline mondiale
                        if (view === 'timeline') {
                            const worldTab = document.querySelector('.timeline-tab[data-mode="world"]');
                            if (worldTab) {
                                // On simule un clic dessus pour tout mettre √† jour proprement
                                worldTab.click();
                            } else {
                                // fallback au cas o√π
                                this.showGlobalTimeline();
                            }
                        }
                    });
                });

                // Onglets mobile en bas
                const mobileTabs = document.querySelectorAll('.mobile-tab');
                mobileTabs.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const view = btn.dataset.mobileView || 'map';
                        this.setMobileMode(view);
                    });
                });


                // Boutons de filtre d'affichage
                document.querySelectorAll('.btn-filter').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.btn-filter').forEach(b => 
                            b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        this.eventDisplayMode = e.target.dataset.filter;
                        this.updateDisplay();
                    });
                });

                // Bouton fiche (pays / personnage)
                const openDetailBtn = document.getElementById('open-detail-sheet');
                if (openDetailBtn) {
                    openDetailBtn.addEventListener('click', () => {
                        if (!this.currentTimelineContext) return;

                        if (this.currentTimelineContext.type === 'country') {
                            this.showCountrySheet(this.currentTimelineContext.name);
                        } else if (this.currentTimelineContext.type === 'person') {
                            this.showPersonSheet(this.currentTimelineContext.name);
                        }
                    });
                }

                // Fermeture de la fiche
                const detailOverlay = document.getElementById('detail-overlay');
                const detailClose = document.getElementById('detail-close');

                if (detailOverlay && detailClose) {
                    detailClose.addEventListener('click', () => {
                        detailOverlay.classList.remove('open');
                    });

                    detailOverlay.addEventListener('click', (e) => {
                        if (e.target === detailOverlay) {
                            detailOverlay.classList.remove('open');
                        }
                    });
                }

                // Slider ann√©e avec champ de saisie synchronis√©
                const yearSlider = document.getElementById('slider-annee');
                const yearInput = document.getElementById('input-annee');

                let debounceTimer;

                // Fonction pour mettre √† jour l'ann√©e
                const updateYear = (newYear) => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        this.selectedYear = newYear;
                        this.updateDisplay();
                    }, 100);
                };

                // Synchronisation slider ‚Üí input
                yearSlider.addEventListener('input', (e) => {
                    const year = parseInt(e.target.value);
                    yearInput.value = year;
                    updateYear(year);
                });

                // Synchronisation input ‚Üí slider
                yearInput.addEventListener('input', (e) => {
                    const year = parseInt(e.target.value);
                    
                    // Validation de l'ann√©e
                    if (year >= -2000 && year <= 2024) {
                        yearSlider.value = year;
                        updateYear(year);
                    }
                });

                // Validation quand on appuie sur Entr√©e
                yearInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const year = parseInt(e.target.value);
                        
                        if (year >= -2000 && year <= 2024) {
                            yearSlider.value = year;
                            updateYear(year);
                            yearInput.blur(); // Enlever le focus
                        } else {
                            alert('Veuillez entrer une ann√©e entre -2000 et 2024');
                            yearInput.value = this.selectedYear; // Revenir √† l'ancienne valeur
                        }
                    }
                });
                
                // Boutons continents
                document.querySelectorAll('.btn-continent').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.btn-continent').forEach(b => 
                            b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        this.selectedContinent = e.target.dataset.continent;
                        this.updateDisplay();
                    });
                });
                
                //  SELECTEURS DE COMPARAISON
                const selectA = document.getElementById("compare-country-a");
                const selectB = document.getElementById("compare-country-b");

                // Fonction pour remplir les listes d√©roulantes de pays
                const fillCountrySelects = () => {
                    // vider au cas o√π
                    selectA.innerHTML = '<option value="">S√©lectionner un pays‚Ä¶</option>';
                    selectB.innerHTML = '<option value="">S√©lectionner un pays‚Ä¶</option>';

                    this.cache.countries.forEach(country => {
                        const optA = document.createElement("option");
                        const optB = document.createElement("option");

                        optA.value = country.pays;
                        optB.value = country.pays;

                        optA.textContent = country.pays;
                        optB.textContent = country.pays;

                        selectA.appendChild(optA);
                        selectB.appendChild(optB);
                    });
                };

                //      BOUTONS DE COMPARAISON
                document.getElementById("compare-btn").addEventListener("click", () => {
                    const countryA = selectA.value;
                    const countryB = selectB.value;

                    if (!countryA || !countryB || countryA === countryB) {
                        this.showNotification("S√©lectionnez deux pays diff√©rents.", "warning");
                        return;
                    }

                    // On stocke les choix
                    this.compareMode = true;
                    this.countryA = countryA;
                    this.countryB = countryB;

                    this.showNotification(`Comparaison activ√©e : ${countryA} vs ${countryB}`, "success");

                    // Lancer l'affichage comparatif (on fera la fonction apr√®s)
                    this.startComparison(countryA, countryB);
                });

                document.getElementById("compare-reset-btn").addEventListener("click", () => {
                    this.compareMode = false;
                    this.countryA = null;
                    this.countryB = null;

                    selectA.value = "";
                    selectB.value = "";

                    this.showNotification("Mode comparaison d√©sactiv√©.", "info");

                    // On remet l'affichage normal
                    this.endComparison();
                });

                // Remplir les selects lorsque les donn√©es sont charg√©es
                setTimeout(fillCountrySelects, 500); // petit d√©lai pour laisser loadData finir

                // Toggle sidebar et timeline
                const sidebarEl = document.getElementById('sidebar');
                const timelineEl = document.getElementById('timeline');
                const toggleSidebarBtn = document.getElementById('toggle-sidebar');
                const toggleTimelineBtn = document.getElementById('toggle-timeline');

                // Masquer / afficher la sidebar
                if (toggleSidebarBtn && sidebarEl) {
                    toggleSidebarBtn.addEventListener('click', () => {
                        sidebarEl.classList.toggle('collapsed');
                    });

                    // Quand la transition de la sidebar est termin√©e -> recalcul carte
                    sidebarEl.addEventListener('transitionend', (e) => {
                        if (!this.map) return;
                        // On ne r√©agit qu'aux changements de largeur / transform
                        if (e.propertyName === 'flex-basis' || e.propertyName === 'max-width' || e.propertyName === 'transform') {
                            this.map.invalidateSize();
                        }
                    });
                }

                // Abaisser / remonter la timeline
                if (toggleTimelineBtn && timelineEl) {
                    toggleTimelineBtn.addEventListener('click', () => {
                        timelineEl.classList.toggle('collapsed');
                        toggleTimelineBtn.textContent = timelineEl.classList.contains('collapsed') ? '‚ñ≤' : '‚ñº';
                    });

                    // Quand la hauteur de la timeline a fini de changer -> recalcul carte
                    timelineEl.addEventListener('transitionend', (e) => {
                        if (!this.map) return;
                        if (e.propertyName === 'height') {
                            this.map.invalidateSize();
                        }
                    });
                }

                // S√©curit√© : si la fen√™tre change de taille ‚Üí recalculer aussi
                window.addEventListener('resize', () => {
                    if (this.map) {
                        this.map.invalidateSize();
                    }
                });

                // Onglets timeline (pays / monde / personnage)
                const timelineTabs = document.querySelectorAll('.timeline-tab');
                const timelineCountry = document.getElementById('timeline-country');
                const timelineGlobal = document.getElementById('timeline-global');

                timelineTabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        timelineTabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');

                        const mode = tab.dataset.mode;

                        if (mode === 'country') {
                            if (timelineCountry) timelineCountry.style.display = 'block';
                            if (timelineGlobal) timelineGlobal.style.display = 'none';
                        } else if (mode === 'world') {
                            if (timelineCountry) timelineCountry.style.display = 'none';
                            if (timelineGlobal) timelineGlobal.style.display = 'block';
                            this.showGlobalTimeline();
                        } else if (mode === 'person') {
                            if (timelineCountry) timelineCountry.style.display = 'block';
                            if (timelineGlobal) timelineGlobal.style.display = 'none';
                        }

                        this.refreshCurrentTimelineView();
                    });
                });
                
                // --- Studio de chronologie : selects & filtre p√©riode & play ---

                const studioCountrySelect = document.getElementById('timeline-country-select');
                const studioPersonSelect = document.getElementById('timeline-person-select');
                const studioFromInput = document.getElementById('timeline-from-year');
                const studioToInput = document.getElementById('timeline-to-year');

                // changement de pays = bascule sur l'onglet "pays" + affichage timeline pays
                if (studioCountrySelect) {
                    studioCountrySelect.addEventListener('change', (e) => {
                        const value = e.target.value;
                        if (!value) return;

                        const tab = document.querySelector('.timeline-tab[data-mode="country"]');
                        if (tab) tab.click(); // d√©clenche toute la logique, puis :
                        this.showTimeline(value);
                    });
                }

                // changement de personnage = onglet "personnage" + timeline perso
                if (studioPersonSelect) {
                    studioPersonSelect.addEventListener('change', (e) => {
                        const value = e.target.value;
                        if (!value) return;

                        const tab = document.querySelector('.timeline-tab[data-mode="person"]');
                        if (tab) tab.click();
                        this.showPersonTimeline(value);
                    });
                }

                // filtre p√©riode : de / √†
                const applyStudioRange = () => {
                    const fromVal = parseInt(studioFromInput?.value);
                    const toVal = parseInt(studioToInput?.value);

                    this.timelineFromYear = isNaN(fromVal) ? null : fromVal;
                    this.timelineToYear = isNaN(toVal) ? null : toVal;

                    this.refreshCurrentTimelineView();
                };

                if (studioFromInput && studioToInput) {
                    studioFromInput.addEventListener('change', applyStudioRange);
                    studioToInput.addEventListener('change', applyStudioRange);
                }

                // Fl√®ches de navigation dans la timeline
                const prevBtn = document.getElementById('timeline-prev');
                const nextBtn = document.getElementById('timeline-next');

                if (prevBtn && nextBtn) {
                    prevBtn.addEventListener('click', () => {
                        this.moveTimeline(-1);
                    });

                    nextBtn.addEventListener('click', () => {
                        this.moveTimeline(1);
                    });
                }
                
                // Export
                document.getElementById('export-btn').addEventListener('click', () => {
                    this.exportData();
                });
                
                // Actualiser
                document.getElementById('refresh-btn').addEventListener('click', () => {
                    this.loadData(true);
                });

                // Annuaire "Tous les √©v√©nements" / "Tous les personnages" / "Tous les pays"
                const openEventsDirBtn = document.getElementById('open-events-directory');
                const openNotesDirBtnMain = document.getElementById('open-notes-directory-main');
                const openPersonsDirBtn = document.getElementById('open-persons-directory');
                const openCountriesDirBtn = document.getElementById('open-countries-directory');
                const closeDirBtn = document.getElementById('directory-close');
                const overlay = this.directoryOverlay;

                if (openEventsDirBtn) {
                    openEventsDirBtn.addEventListener('click', () => {
                        this.openEventsDirectory();
                    });
                }

                if (openNotesDirBtnMain) {
                    openNotesDirBtnMain.addEventListener('click', () => {
                        this.openNotesDirectory();
                    });
                }

                if (openPersonsDirBtn) {
                    openPersonsDirBtn.addEventListener('click', () => {
                        this.openPersonsDirectory();
                    });
                }

                if (openCountriesDirBtn) {
                    openCountriesDirBtn.addEventListener('click', () => {
                        this.openCountriesDirectory();
                    });
                }

                if (overlay && closeDirBtn) {
                    closeDirBtn.addEventListener('click', () => {
                        this.closeDirectory();
                    });

                    // clic sur le fond sombre = fermeture
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            this.closeDirectory();
                        }
                    });

                    // touche √âchap = fermeture
                    window.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            this.closeDirectory();
                        }
                    });
                }

            }
            
            initObsidianSync() {
                // Bouton sync manuel
                document.getElementById('sync-now').addEventListener('click', () => {
                    this.triggerSync();
                });
                
                // Toggle surveillance
                document.getElementById('watch-toggle').addEventListener('click', () => {
                    this.toggleWatch();
                });
                
                // Polling pour v√©rifier les mises √† jour
                this.startPolling();
                
                // Mettre √† jour l'affichage de la derni√®re sync
                this.updateLastSyncDisplay();
            }
            
            async loadData(forceReload = false) {
                if (this.isLoading && !forceReload) return;
                
                this.isLoading = true;
                this.showLoading(true);
                this.setSyncStatus('syncing', 'Chargement...');
                
                try {
                    console.log("üì¶ Chargement des donn√©es...");
                    const cacheBuster = forceReload ? ('?t=' + Date.now()) : '';
                    
                    // Charger √©v√©nements, pays et personnages en parall√®le
                    const [eventsResponse, countriesResponse, personsResponse, notesResponse] = await Promise.all([
                        fetch(this.dataUrls.events + cacheBuster),
                        fetch(this.dataUrls.countries + cacheBuster),
                        fetch(this.dataUrls.persons + cacheBuster).catch(() => null),
                        fetch(this.dataUrls.notes + cacheBuster).catch(() => null)
                    ]);
                    
                    if (!eventsResponse.ok || !countriesResponse.ok) {
                        throw new Error('Erreur de chargement des donn√©es principales');
                    }

                    this.cache.events = await eventsResponse.json();
                    this.cache.countries = await countriesResponse.json();
                    this.cache.persons = [];
                    this.cache.notes = [];

                    if (personsResponse && personsResponse.ok) {
                        try {
                            const personsJson = await personsResponse.json();
                            this.cache.persons = Array.isArray(personsJson) ? personsJson : [];
                        } catch (e) {
                            console.warn('‚ö†Ô∏è Impossible de parser personnes.json, on continue sans les fiches personnages.', e);
                        }
                    }

                    if (notesResponse && notesResponse.ok) {
                        try {
                            const notesJson = await notesResponse.json();
                            this.cache.notes = Array.isArray(notesJson) ? notesJson : [];
                        } catch (e) {
                            console.warn('‚ö†Ô∏è Impossible de parser notes.json, on continue sans les notes d√©di√©es.', e);
                        }
                    }

                    // Fallback : si aucune note d√©di√©e, on r√©utilise la liste des √©v√©nements
                    if (!this.cache.notes || this.cache.notes.length === 0) {
                        this.cache.notes = [...this.cache.events];
                    }

                    this.cache.lastSync = new Date();
                    this.buildPersonsIndex();
                    this.populateTimelineSelectors();

                    console.log(`‚úÖ ${this.cache.events.length} √©v√©nements, ${this.cache.countries.length} pays, ${this.cache.persons.length} personnages et ${this.cache.notes.length} notes charg√©s`);
                    this.setSyncStatus('success', 'Synchronis√©');
                    this.showNotification('üì¶ Donn√©es mises √† jour', 'success');
                    
                } catch (error) {
                    console.error("‚ùå Erreur de chargement:", error);
                    this.setSyncStatus('error', 'Erreur');
                    this.showNotification('‚ùå Erreur de chargement des donn√©es', 'error');
                    
                    // Donn√©es de fallback si aucune donn√©e n'est disponible
                    if (this.cache.events.length === 0) {
                        this.loadFallbackData();
                    }
                } finally {
                    this.isLoading = false;
                    this.showLoading(false);
                    this.updateLastSyncDisplay();
                }
            }
            
            loadFallbackData() {
                console.log("üîÑ Chargement des donn√©es de test");
                
                this.cache.countries = [
                    { pays: "France", continent: "europe", coordonnees: [46.603354, 1.888334] },
                    { pays: "Allemagne", continent: "europe", coordonnees: [51.165691, 10.451526] },
                    { pays: "√âtats-Unis", continent: "amerique", coordonnees: [37.09024, -95.712891] },
                    { pays: "Chine", continent: "asie", coordonnees: [35.86166, 104.195397] },
                    { pays: "√âgypte", continent: "afrique", coordonnees: [26.820553, 30.802498] }
                ];
                
                this.cache.events = [
                    {
                        pays: "France",
                        date: "1789-07-14",
                        titre: "Prise de la Bastille",
                        description: "D√©but de la R√©volution fran√ßaise",
                        categorie: "politique",
                        lien: "#"
                    },
                    {
                        pays: "√âtats-Unis",
                        date: "1776-07-04",
                        titre: "D√©claration d'ind√©pendance",
                        description: "Naissance des √âtats-Unis",
                        categorie: "politique",
                        lien: "#"
                    }
                ];
                
                this.showNotification('‚ö†Ô∏è Donn√©es de test charg√©es', 'warning');
            }
            
            buildPersonsIndex() {
                const index = {};

                // 1) M√©tadonn√©es Obsidian (data/personnes.json)
                (this.cache.persons || []).forEach(meta => {
                    if (!meta || !meta.nom) return;

                    index[meta.nom] = {
                        nom: meta.nom,
                        titre: meta.titre || meta.nom,
                        events: [],
                        naissance: meta.naissance || null,
                        mort: meta.mort || null,
                        lieuNaissance: meta.lieu_naissance || null,
                        lieuMort: meta.lieu_mort || null,
                        fonction: meta.fonction || null,
                        paysPrincipaux: Array.isArray(meta.pays_principaux) ? meta.pays_principaux : [],
                        image: meta.image || null,
                        bioCourte: meta.bio_courte || null,
                        bioLongue: meta.bio_longue || null,
                        sources: meta.sources || null
                    };
                });

                // 2) √âv√®nements : on rattache les √©v√©nements aux personnes
                (this.cache.events || []).forEach(ev => {
                    const persons = ev.personnages || ev.personnages_list || ev.persons;
                    if (!persons) return;

                    let list = persons;
                    if (typeof list === 'string') {
                        list = list.split(',').map(p => p.trim()).filter(Boolean);
                    }

                    list.forEach(name => {
                        if (!name) return;
                        if (!index[name]) {
                            // Personnage cit√© seulement dans les √©v√©nements (pas encore de fiche Obsidian)
                            index[name] = {
                                nom: name,
                                titre: name,
                                events: [],
                                naissance: null,
                                mort: null,
                                lieuNaissance: null,
                                lieuMort: null,
                                fonction: null,
                                paysPrincipaux: [],
                                image: null,
                                bioCourte: null,
                                sources: null
                            };
                        }
                        index[name].events.push(ev);
                    });
                });

                this.personIndex = index;
            }

            populateTimelineSelectors() {
                const countrySelect = document.getElementById('timeline-country-select');
                const personSelect = document.getElementById('timeline-person-select');

                if (countrySelect) {
                    countrySelect.innerHTML = `<option value="">pays‚Ä¶</option>`;

                    const countries = (this.cache.countries || [])
                        .slice()
                        .sort((a, b) => a.pays.localeCompare(b.pays, 'fr'));

                    countries.forEach(c => {
                        const opt = document.createElement('option');
                        opt.value = c.pays;
                        opt.textContent = c.pays;
                        countrySelect.appendChild(opt);
                    });
                }

                if (personSelect) {
                    personSelect.innerHTML = `<option value="">personnage‚Ä¶</option>`;

                    const persons = Object.keys(this.personIndex || {})
                        .slice()
                        .sort((a, b) => a.localeCompare(b, 'fr'));

                    persons.forEach(name => {
                        const opt = document.createElement('option');
                        opt.value = name;
                        opt.textContent = name;
                        personSelect.appendChild(opt);
                    });
                }
            }

            filterEventsByTimelinePeriod(events) {
                if (!events || events.length === 0) return [];
                const fromY = this.timelineFromYear;
                const toY = this.timelineToYear;

                if (fromY == null && toY == null) return events;

                return events.filter(ev => {
                    if (!ev.date || typeof ev.date !== 'string') return false;
                    const yearStr = ev.date.split('-')[0];
                    const year = parseInt(yearStr, 10);
                    if (isNaN(year)) return false;

                    if (fromY != null && year < fromY) return false;
                    if (toY != null && year > toY) return false;
                    return true;
                });
            }
            
            // --- Helpers pour la vue "chronologie" ---

            getEventYear(ev) {
                if (!ev || !ev.date || typeof ev.date !== 'string') return null;
                const yearStr = ev.date.split('-')[0];
                const year = parseInt(yearStr, 10);
                return isNaN(year) ? null : year;
            }

            getCenturyLabel(year) {
                if (year == null) return '?';
                const abs = Math.abs(year);
                const centuryNumber = Math.floor((abs - 1) / 100) + 1;
                if (year <= 0) {
                    return `${centuryNumber}e s. av. J.-C.`;
                } else {
                    return `${centuryNumber}e si√®cle`;
                }
            }

            summarizePeriod(events) {
                const years = (events || [])
                    .map(ev => this.getEventYear(ev))
                    .filter(y => y != null);
                if (!years.length) return null;

                const minYear = Math.min(...years);
                const maxYear = Math.max(...years);

                return {
                    minYear,
                    maxYear,
                    label: `${this.getCenturyLabel(minYear)} ‚Üí ${this.getCenturyLabel(maxYear)}`
                };
            }

            groupEventsByCentury(events) {
                const groups = {};

                (events || []).forEach(ev => {
                    const year = this.getEventYear(ev);
                    if (year == null) return;

                    const abs = Math.abs(year);
                    const centuryNumber = Math.floor((abs - 1) / 100) + 1;
                    const key = (year <= 0 ? '-' : '') + centuryNumber;

                    if (!groups[key]) {
                        groups[key] = {
                            sign: year <= 0 ? -1 : 1,
                            num: centuryNumber,
                            label: this.getCenturyLabel(year),
                            events: []
                        };
                    }
                    groups[key].events.push(ev);
                });

                const keys = Object.keys(groups);
                // tri chronologique des si√®cles
                keys.sort((a, b) => {
                    const ga = groups[a];
                    const gb = groups[b];
                    const startA = ga.sign === -1 ? -(ga.num * 100) : (ga.num - 1) * 100 + 1;
                    const startB = gb.sign === -1 ? -(gb.num * 100) : (gb.num - 1) * 100 + 1;
                    return startA - startB;
                });

                return keys.map(k => groups[k]);
            }

            buildTimelineList(events, options = {}) {
                const {
                    title,
                    showCountries = true,
                    showMiniMap = true,             // NEW
                    extraSummaryFooterHtml = ''     // NEW : ce qu‚Äôon met √† la place de la mini-map
                } = options;

                const summary = this.summarizePeriod(events);
                const centuryGroups = this.groupEventsByCentury(events);

                let html = '';

                if (title) {
                    html += `<h3 class="timeline-section-title">${title}</h3>`;
                }

                if (summary) {
                    html += `
                        <div class="timeline-summary">
                            <div class="timeline-summary-line">
                                <span class="summary-label">p√©riode couverte</span>
                                <span class="summary-value">${summary.minYear} ‚Üí ${summary.maxYear}</span>
                            </div>
                            <div class="timeline-summary-line">
                                <span class="summary-label">rep√®re</span>
                                <span class="summary-value">${summary.label}</span>
                            </div>
                            <div class="timeline-summary-line">
                                <span class="summary-label">√©v√®nements</span>
                                <span class="summary-value">${events.length}</span>
                            </div>
                        </div>
                    `;

                    // üëâ soit mini-map, soit un bloc custom (personnages)
                    if (showMiniMap) {
                        html += `<div id="timeline-mini-map" class="timeline-mini-map"></div>`;
                    } else if (extraSummaryFooterHtml) {
                        html += extraSummaryFooterHtml;
                    }
                }

                html += `<div class="timeline-century-list">`;

                centuryGroups.forEach((group, groupIndex) => {
                    html += `
                        <section class="timeline-century-group" data-century-index="${groupIndex}">
                            <header class="timeline-century-header">
                                <button type="button" class="timeline-century-toggle" aria-expanded="true">
                                    <span class="century-label">${group.label}</span>
                                    <span class="century-count">${group.events.length} √©v√®nement(s)</span>
                                    <span class="chevron">‚ñæ</span>
                                </button>
                            </header>
                            <div class="timeline-century-events">
                    `;

                    group.events.forEach(ev => {
                        const icon = this.getCategoryIcon(ev.categorie);
                        const year = this.getEventYear(ev);
                        const paysList = showCountries ? this.eventCountries(ev).join(', ') : '';
                        const lat = ev.latitude ?? ev.lat ?? '';
                        const lng = ev.longitude ?? ev.lng ?? '';

                        const indexGlobal = events.indexOf(ev);

                        html += `
                            <article class="timeline-event-card"
                                    data-global-index="${indexGlobal}"
                                    data-lat="${lat}"
                                    data-lng="${lng}">
                                <div class="event-date-row">
                                    <span class="event-year">${year != null ? year : (ev.date || '')}</span>
                                    ${paysList ? `<span class="event-country">${paysList}</span>` : ''}
                                </div>
                                <div class="event-title-row">
                                    <span class="event-icon">${icon}</span>
                                    <span class="event-title">${ev.titre}</span>
                                </div>
                                ${ev.description ? `<p class="event-description">${ev.description}</p>` : ''}
                            </article>
                        `;
                    });

                    html += `
                            </div>
                        </section>
                    `;
                });

                html += `</div>`;
                return html;
            }

            setupCenturyCollapsibles(container) {
                if (!container) return;
                container.querySelectorAll('.timeline-century-group').forEach(group => {
                    const btn = group.querySelector('.timeline-century-toggle');
                    if (!btn) return;
                    btn.addEventListener('click', () => {
                        const collapsed = group.classList.toggle('collapsed');
                        btn.setAttribute('aria-expanded', (!collapsed).toString());
                    });
                });
            }

            initTimelineMiniMap() {
                const container = document.getElementById('timeline-mini-map');
                if (!container) return;

                if (this.timelineMiniMap) {
                    this.timelineMiniMap.invalidateSize();
                    return;
                }

                this.timelineMiniMap = L.map(container, {
                    center: [20, 0],
                    zoom: 1,
                    zoomControl: false,
                    attributionControl: false,
                    dragging: false,
                    scrollWheelZoom: false,
                    doubleClickZoom: false,
                    boxZoom: false,
                    keyboard: false,
                    tap: false
                });

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 6
                }).addTo(this.timelineMiniMap);

                this.timelineMiniLayer = L.layerGroup().addTo(this.timelineMiniMap);
            }

            updateTimelineMiniMap(events) {
                this.initTimelineMiniMap();
                if (!this.timelineMiniMap || !this.timelineMiniLayer) return;

                this.timelineMiniLayer.clearLayers();
                const coords = [];

                (events || []).forEach(ev => {
                    const lat = parseFloat(ev.latitude ?? ev.lat);
                    const lng = parseFloat(ev.longitude ?? ev.lng);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        coords.push([lat, lng]);
                        L.circleMarker([lat, lng], { radius: 4 }).addTo(this.timelineMiniLayer);
                    }
                });

                if (coords.length) {
                    const bounds = L.latLngBounds(coords);
                    this.timelineMiniMap.fitBounds(bounds, { padding: [10, 10] });
                } else {
                    this.timelineMiniMap.setView([20, 0], 1);
                }
            }

            setupTimelineListInteractions(container, events, mode = 'world') {
                if (!container) return;

                this.setupCenturyCollapsibles(container);

                const hasMiniMap = !!container.querySelector('#timeline-mini-map');

                container.querySelectorAll('.timeline-event-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const idx = parseInt(card.getAttribute('data-global-index'), 10);
                        if (!isNaN(idx)) {
                            if (mode === 'world') {
                                this.focusGlobalTimelineEvent(idx);
                            } else {
                                this.focusTimelineEvent(idx);
                            }
                        }

                        if (hasMiniMap) {
                            const lat = parseFloat(card.getAttribute('data-lat'));
                            const lng = parseFloat(card.getAttribute('data-lng'));
                            if (!isNaN(lat) && !isNaN(lng)) {
                                this.updateTimelineMiniMap([{ latitude: lat, longitude: lng }]);
                            }
                        }
                    });
                });

                // mini-carte initiale sur l'ensemble de la p√©riode (uniquement si pr√©sente)
                if (hasMiniMap) {
                    this.updateTimelineMiniMap(events);
                }

                // Clic sur un personnage dans la vue chronologie (inline sous le r√©sum√©)
                container.querySelectorAll('.timeline-inline-person-chip').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const name = btn.getAttribute('data-person');
                        if (!name) return;
                        this.showPersonSheet(name);
                    });
                });

                // Clic sur un pays dans la vue chronologie (inline sous le r√©sum√© d'un personnage)
                container.querySelectorAll('.timeline-inline-country-chip').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const country = btn.getAttribute('data-country');
                        if (!country) return;
                        this.showCountrySheet(country);
                    });
                });
            }

            autoAdjustGlobalTimelineZoom(events) {
                if (!events || !events.length) return;
                const years = events
                    .map(ev => this.getEventYear(ev))
                    .filter(y => y != null);
                if (!years.length) return;

                const span = Math.max(...years) - Math.min(...years);

                let zoom = 1;
                if (span > 2500) zoom = 0.5;
                else if (span > 1500) zoom = 0.7;
                else if (span > 800) zoom = 1;
                else if (span > 300) zoom = 1.5;
                else if (span > 120) zoom = 2;
                else zoom = 3;

                if (typeof this.timelineGlobalMinZoom === 'number' &&
                    typeof this.timelineGlobalMaxZoom === 'number') {
                    zoom = Math.max(this.timelineGlobalMinZoom, Math.min(this.timelineGlobalMaxZoom, zoom));
                }

                this.timelineGlobalZoom = zoom;
            }

            updateDisplay() {
                if (this.isLoading) return;
                
                requestAnimationFrame(() => {
                    this.updateMarkers();
                    this.updateStats();
                    this.updateEventsList();
                    this.updatePersonsList();
                    this.updateCountriesList();
                    this.updateNotesList();
                    if (this.mainView === 'notes' && typeof this.renderNotesPanel === 'function') {
                        this.renderNotesPanel();
                    }
                });

                // Si l'onglet "Timeline mondiale" est actif, on la met aussi √† jour
                const worldTab = document.querySelector('.timeline-tab[data-mode="world"]');
                if (worldTab && worldTab.classList.contains('active')) {
                    this.showGlobalTimeline();
                }
            }
            
            updateMarkers() {
                this.markers.clearLayers();
                
                // Filtrer les pays
                let filteredCountries = this.cache.countries;
                if (this.selectedContinent !== "tous") {
                    filteredCountries = this.cache.countries.filter(
                        country => country.continent === this.selectedContinent
                    );
                }
                
                // Cr√©er les marqueurs
                filteredCountries.forEach(country => {
                    const events = this.getEventsForCountry(country.pays);
                    if (events.length > 0) {
                        this.createMarker(country, events);
                    }
                });
            }
            
            updatePersonsList() {
                const container = document.getElementById('persons-list');
                if (!container) return;

                const entries = Object.values(this.personIndex);

                if (entries.length === 0) {
                    container.innerHTML = '<p class="no-events">Aucun personnage r√©f√©renc√©.</p>';
                    return;
                }

                // tri simple : par nombre d'√©v√©nements puis par nom
                entries.sort((a, b) => {
                    if (b.events.length !== a.events.length) {
                        return b.events.length - a.events.length;
                    }
                    return a.nom.localeCompare(b.nom, 'fr');
                });

                let html = '';
                entries.forEach(person => {
                    // Pays principaux (on r√©cup√®re tous les pays associ√©s aux √©v√©nements)
                    const paysSet = new Set();
                    person.events.forEach(ev => {
                        this.eventCountries(ev).forEach(p => paysSet.add(p));
                    });
                    const paysList = Array.from(paysSet).join(', ');

                    html += `
                        <div class="event-item person-item" data-person="${person.nom}">
                            <div class="event-title">${person.nom}</div>
                            <div class="event-date">
                                ${person.events.length} √©v√©nement(s)
                                ${paysList ? ` ‚Äì ${paysList}` : ''}
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html;

                // Gestion du clic : ouvrir la "page" du personnage
                container.querySelectorAll('.person-item').forEach(el => {
                    el.addEventListener('click', () => {
                        const name = el.getAttribute('data-person');
                        this.showPersonPage(name);
                    });
                });
            }

            updateCountriesList() {
                const container = document.getElementById('countries-list');
                if (!container || !this.cache || !Array.isArray(this.cache.countries)) return;

                // On respecte le filtre de continent de la carte
                let filteredCountries = this.cache.countries;
                if (this.selectedContinent !== "tous") {
                    filteredCountries = this.cache.countries.filter(
                        country => country.continent === this.selectedContinent
                    );
                }

                const allEvents = this.cache.events || [];

                // Pour chaque pays : on r√©cup√®re tous les events + la date la plus r√©cente
                const entries = filteredCountries.map(country => {
                    const eventsForCountry = allEvents.filter(ev =>
                        this.eventBelongsToCountry(ev, country.pays)
                    );

                    if (!eventsForCountry.length) {
                        return null;
                    }

                    let lastTimestamp = -Infinity;
                    eventsForCountry.forEach(ev => {
                        if (!ev.date) return;
                        const d = new Date(ev.date);
                        if (!isNaN(d.getTime()) && d.getTime() > lastTimestamp) {
                            lastTimestamp = d.getTime();
                        }
                    });

                    return {
                        country,
                        events: eventsForCountry,
                        lastTimestamp
                    };
                }).filter(Boolean);

                if (!entries.length) {
                    container.innerHTML = '<p class="no-events">Aucun pays r√©f√©renc√©.</p>';
                    return;
                }

                // Tri : pays dont le dernier √©v√©nement est le plus r√©cent en premier
                entries.sort((a, b) => {
                    if (b.lastTimestamp !== a.lastTimestamp) {
                        return b.lastTimestamp - a.lastTimestamp;
                    }
                    return a.country.pays.localeCompare(b.country.pays, 'fr', { sensitivity: 'base' });
                });

                let html = '';
                entries.forEach(entry => {
                    const c = entry.country;
                    const events = entry.events;
                    let lastYear = '';

                    if (entry.lastTimestamp && entry.lastTimestamp !== -Infinity) {
                        lastYear = new Date(entry.lastTimestamp).getFullYear();
                    }

                    html += `
                        <div class="event-item country-item" data-country="${c.pays}">
                            <div class="event-title">${c.pays}</div>
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html;

                // Clic sur un pays de la liste = ouvre la fiche pays dans la sidebar
                container.querySelectorAll('.country-item').forEach(el => {
                    el.addEventListener('click', () => {
                        const name = el.getAttribute('data-country');
                        if (!name) return;
                        if (typeof this.showCountrySidebarSheet === 'function') {
                            this.showCountrySidebarSheet(name);
                        } else {
                            // fallback si un jour tu veux : this.showCountrySheet(name);
                            this.showCountrySheet && this.showCountrySheet(name);
                        }
                    });
                });
            }

            showPersonPage(name) {
                this.currentTimelineContext = {
                    type: 'person',
                    name: name
                };

                this.showPersonSheet(name);
            }
            
            showPersonTimeline(personName) {
                this.currentTimelineContext = {
                    type: 'person',
                    name: personName
                };

                const timeline = document.getElementById('timeline');
                const timelineContent = document.getElementById('timeline-content');
                const timelineCountry = document.getElementById('timeline-country');
                const timelineGlobal = document.getElementById('timeline-global');

                if (!timeline || !timelineContent) return;

                if (timelineCountry) timelineCountry.style.display = 'block';
                if (timelineGlobal) timelineGlobal.style.display = 'none';

                const p = this.personIndex[personName];
                if (!p || !p.events || !p.events.length) {
                    timelineContent.innerHTML = `
                        <h3 class="timeline-section-title">üìú Timeline ‚Äì ${personName}</h3>
                        <p>Aucun √©v√©nement trouv√© pour ${personName}.</p>
                    `;
                    this.drawTimeline([]);
                    return;
                }

                let events = p.events.slice().sort(
                    (a, b) => new Date(a.date) - new Date(b.date)
                );

                events = this.filterEventsByTimelinePeriod(events);

                if (!events.length) {
                    timelineContent.innerHTML = `
                        <h3 class="timeline-section-title">üìú Timeline ‚Äì ${personName}</h3>
                        <p>Aucun √©v√©nement dans cette p√©riode.</p>
                    `;
                    this.drawTimeline([]);
                    return;
                }

                // frise locale
                this.drawTimeline(events);
                this.currentTimelineEvents = events;

                // liste structur√©e par si√®cle
                const title = `üìú Timeline ‚Äì ${personName}`;
                timelineContent.innerHTML = this.buildTimelineList(events, {
                    title,
                    showCountries: true,
                    showMiniMap: false,
                    extraSummaryFooterHtml: this.buildPersonCountriesInline(personName)
                });

                this.setupTimelineListInteractions(timelineContent, events, 'country');
            }

            showCountrySheet(countryName) {
                const overlay = document.getElementById('detail-overlay');
                const titleEl = document.getElementById('detail-title');
                const subtitleEl = document.getElementById('detail-subtitle');
                const statsEl = document.getElementById('detail-stats');
                const timelineEl = document.getElementById('detail-timeline');
                const personsEl = document.getElementById('detail-persons');
                const personsTitleEl = document.getElementById('detail-persons-title');

                const bioSection = document.getElementById('detail-bio-section');
                const bioEl = document.getElementById('detail-bio');
                if (bioSection && bioEl) {
                    bioSection.style.display = 'none';
                    bioEl.innerHTML = '';
                }

                if (!overlay || !titleEl || !statsEl || !timelineEl || !personsEl) return;

                const country = (this.cache.countries || []).find(
                    c => c.pays.toLowerCase() === countryName.toLowerCase()
                );

                const events = (this.cache.events || []).filter(ev =>
                    this.eventBelongsToCountry(ev, countryName)
                ).sort((a, b) => new Date(a.date) - new Date(b.date));

                // --- Titre / sous-titre ---
                titleEl.textContent = countryName;
                if (personsTitleEl) {
                    personsTitleEl.textContent = 'personnages majeurs.';
                }

                if (events.length > 0) {
                    const years = events
                        .map(ev => parseInt(ev.date.split('-')[0], 10))
                        .filter(y => !isNaN(y));
                    const minY = Math.min(...years);
                    const maxY = Math.max(...years);
                    subtitleEl.textContent = `‚âà ${events.length} √©v√©nement(s) de ${minY} √† ${maxY}`;
                } else {
                    subtitleEl.textContent = `aucun √©v√©nement encore li√© √† ce pays.`;
                }

                // --- Stats ---
                const categories = {};
                events.forEach(ev => {
                    const cat = ev.categorie || 'autre';
                    categories[cat] = (categories[cat] || 0) + 1;
                });

                const years = events
                    .map(ev => parseInt(ev.date.split('-')[0], 10))
                    .filter(y => !isNaN(y));

                const minY = years.length ? Math.min(...years) : null;
                const maxY = years.length ? Math.max(...years) : null;

                statsEl.innerHTML = `
                    <div class="detail-stats-grid">
                        <div>
                            <div class="detail-stat-label">√©v√©nements</div>
                            <div class="detail-stat-value">${events.length}</div>
                        </div>
                        <div>
                            <div class="detail-stat-label">p√©riode</div>
                            <div class="detail-stat-value">
                                ${minY !== null ? minY : '?'} ‚Äì ${maxY !== null ? maxY : '?'}
                            </div>
                        </div>
                        <div>
                            <div class="detail-stat-label">cat√©gories</div>
                            <div class="detail-stat-value">
                                ${Object.keys(categories).length || '‚Äì'}
                            </div>
                        </div>
                    </div>
                `;

                if (events.length === 0) {
                    timelineEl.innerHTML = `<p class="no-events">Aucun √©v√©nement √† afficher.</p>`;
                } else {
                    timelineEl.innerHTML = events.map(ev => {
                        const lien  = ev.lien && ev.lien !== '#' ? ev.lien : null;
                        const date  = ev.date  || '';
                        const titre = ev.titre || '(sans titre)';

                        return `
                            <button class="detail-timeline-item"
                                    ${lien ? `data-lien="${lien}"` : ''}>
                                <span class="detail-timeline-date">${date}</span>
                                <span class="detail-timeline-separator">‚Äî</span>
                                <span class="detail-timeline-title">${titre}</span>
                            </button>
                        `;
                    }).join('');
                }
                
                // Clic sur un √©v√©nement de la chronologie = ouvrir la fiche individuelle (si lien dispo)
                timelineEl.querySelectorAll('.detail-timeline-item[data-lien]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const url = btn.getAttribute('data-lien');
                        if (url) {
                            window.open(url, '_blank');
                        }
                    });
                });

                // --- Personnages majeurs (tri√©s par nb d‚Äô√©v√©nements) ---
                const personsStats = [];

                if (this.personIndex) {
                    Object.values(this.personIndex).forEach(p => {
                        const count = (p.events || []).filter(ev =>
                            this.eventBelongsToCountry(ev, countryName)
                        ).length;
                        if (count > 0) {
                            personsStats.push({ nom: p.nom, count });
                        }
                    });
                }

                personsStats.sort((a, b) => b.count - a.count);

                if (personsStats.length === 0) {
                    personsEl.innerHTML = `<p>Aucun personnage encore reli√© √† ce pays.</p>`;
                } else {
                    personsEl.innerHTML = `
                        <div class="detail-persons-list">
                            ${personsStats.slice(0, 20).map(p => `
                                <button class="detail-person-chip" data-person="${p.nom}">
                                    ${p.nom} (${p.count})
                                </button>
                            `).join('')}
                        </div>
                    `;

                    // Clic sur une pastille = ouvrir fiche personnage
                    personsEl.querySelectorAll('.detail-person-chip').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const name = btn.getAttribute('data-person');
                            this.showPersonSheet(name);
                        });
                    });
                }

                // --- Mini-carte centr√©e sur le pays ---
                const mapDiv = document.getElementById('detail-map');
                if (mapDiv) {
                    // Si une ancienne carte existe mais n'est pas attach√©e au bon conteneur, on la d√©truit
                    if (this.detailMap && this.detailMap._container !== mapDiv) {
                        this.detailMap.remove();
                        this.detailMap = null;
                    }

                    // Initialisation si n√©cessaire
                    if (!this.detailMap) {
                        this.detailMap = L.map(mapDiv, {
                            center: [20, 0],
                            zoom: 3,
                            zoomControl: false,
                            attributionControl: false
                        });
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            maxZoom: 10
                        }).addTo(this.detailMap);
                    }

                    // Ici tu recentres selon le contexte :
                    // üëâ pour un PAYS :
                    // if (country && country.coordonnees) {
                    //     const [lat, lng] = country.coordonnees;
                    //     this.detailMap.setView([lat, lng], 4);
                    // }

                    // üëâ pour un PERSONNAGE :
                    // const firstWithCoords = events.find(ev => Array.isArray(ev.coords) && ev.coords.length === 2);
                    // if (firstWithCoords) {
                    //     const [lat, lng] = firstWithCoords.coords;
                    //     this.detailMap.setView([lat, lng], 4);
                    // }

                    setTimeout(() => this.detailMap.invalidateSize(), 150);
                }

                overlay.classList.add('open');
            }

            showCountrySidebarSheet(countryName) {
                const main = document.getElementById('sidebar-main');
                const detail = document.getElementById('sidebar-detail');
                if (!main || !detail) return;

                const country = (this.cache.countries || []).find(
                    c => c.pays.toLowerCase() === countryName.toLowerCase()
                );

                const events = (this.cache.events || [])
                    .filter(ev => this.eventBelongsToCountry(ev, countryName))
                    .sort((a, b) => new Date(a.date) - new Date(b.date));

                const years = events
                    .map(ev => parseInt((ev.date || '').split('-')[0], 10))
                    .filter(y => !isNaN(y));

                const minY = years.length ? Math.min(...years) : null;
                const maxY = years.length ? Math.max(...years) : null;

                const categories = {};
                events.forEach(ev => {
                    const cat = ev.categorie || 'autre';
                    categories[cat] = (categories[cat] || 0) + 1;
                });

                // Personnages li√©s √† ce pays
                const personsStats = [];
                if (this.personIndex) {
                    Object.values(this.personIndex).forEach(p => {
                        const count = (p.events || []).filter(ev =>
                            this.eventBelongsToCountry(ev, countryName)
                        ).length;
                        if (count > 0) {
                            personsStats.push({ nom: p.nom, count });
                        }
                    });
                }
                personsStats.sort((a, b) => b.count - a.count);

                // HTML de la chronologie condens√©e (√©v√®nements cliquables)
                const timelineHtml = events.length === 0
                    ? `<p class="no-events">Aucun √©v√©nement √† afficher.</p>`
                    : events.map(ev => {
                        const lien = ev.lien && ev.lien !== '#' ? ev.lien : null;
                        const date = ev.date || '';
                        const titre = ev.titre || '(sans titre)';

                        return `
                            <button class="detail-timeline-item"
                                    ${lien ? `data-lien="${lien}"` : ''}>
                                <span class="detail-timeline-date">${date}</span>
                                <span class="detail-timeline-separator">‚Äî</span>
                                <span class="detail-timeline-title">${titre}</span>
                            </button>
                        `;
                    }).join('');

                // HTML de la liste de personnages (scrollable)
                let personsHtml;
                if (personsStats.length === 0) {
                    personsHtml = `<p class="no-events">Aucun personnage encore reli√© √† ce pays.</p>`;
                } else {
                    personsHtml = `
                        <div class="detail-persons-scroll">
                            <div class="detail-persons-list">
                                ${personsStats.slice(0, 20).map(p => `
                                    <button class="detail-person-chip" data-person="${p.nom}">
                                        ${p.nom} (${p.count})
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                // HTML de la fiche dans la sidebar
                detail.innerHTML = `
                    <button type="button" id="sidebar-back-btn" class="btn btn-secondary" style="margin-bottom: 8px;">
                        ‚Üê retour
                    </button>

                    <h3 style="margin-bottom: 8px; font-size: 0.95rem; text-transform: none;">
                        ${countryName}
                    </h3>

                    <div id="sidebar-country-map" style="
                        width: 100%;
                        height: 140px;
                        border-radius: 10px;
                        border: 1px solid var(--couleur-bordure);
                        margin-bottom: 10px;
                        overflow: hidden;
                    "></div>

                    <div class="detail-stats" style="margin-bottom: 10px;">
                        <div class="detail-stats-grid">
                            <div>
                                <div class="detail-stat-label">√©v√©nements</div>
                                <div class="detail-stat-value">${events.length}</div>
                            </div>
                            <div>
                                <div class="detail-stat-label">p√©riode</div>
                                <div class="detail-stat-value">
                                    ${minY !== null ? minY : '?'} ‚Äì ${maxY !== null ? maxY : '?'}
                                </div>
                            </div>
                            <div>
                                <div class="detail-stat-label">cat√©gories</div>
                                <div class="detail-stat-value">
                                    ${Object.keys(categories).length || '‚Äì'}
                                </div>
                            </div>
                        </div>
                    </div>

                    <section class="detail-section" style="margin-bottom: 10px;">
                        <h3 class="detail-section-title-clickable">chronologie condens√©e.</h3>
                        <div class="detail-timeline-scroll">
                            <div id="sidebar-country-timeline">
                                ${timelineHtml}
                            </div>
                        </div>
                    </section>

                    <section class="detail-section">
                        <h3>personnages majeurs.</h3>
                        <div id="sidebar-country-persons">
                            ${personsHtml}
                        </div>
                    </section>
                `;

                // Bouton retour : on r√©-affiche la vue principale
                const backBtn = document.getElementById('sidebar-back-btn');
                if (backBtn) {
                    backBtn.addEventListener('click', () => {
                        detail.style.display = 'none';
                        main.style.display = 'block';
                    });
                }

                // Clic sur un personnage = fiche personnage popup
                detail.querySelectorAll('.detail-person-chip').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const name = btn.getAttribute('data-person');
                        if (!name) return;
                        this.showPersonSheet(name);
                    });
                });

                // Clic sur le titre "chronologie condens√©e." = ouvre l'index des √©v√©nements
                const chronoTitle = detail.querySelector('.detail-section-title-clickable');
                if (chronoTitle && typeof this.openEventsDirectory === 'function') {
                    chronoTitle.addEventListener('click', () => {
                        this.openEventsDirectory();
                    });
                }

                // Clic sur un √©v√©nement de la liste = ouvre la fiche individuelle (lien g√©n√©r√©)
                const timelineContainer = detail.querySelector('#sidebar-country-timeline');
                if (timelineContainer) {
                    timelineContainer.querySelectorAll('.detail-timeline-item[data-lien]').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const url = btn.getAttribute('data-lien');
                            if (url) {
                                window.open(url, '_blank');
                            }
                        });
                    });
                }

                // Afficher la vue d√©tail dans la sidebar
                main.style.display = 'none';
                detail.style.display = 'block';

                // Mini-carte dans la sidebar
                const mapDiv = document.getElementById('sidebar-country-map');
                if (mapDiv) {
                    // Si une ancienne carte existe mais est attach√©e √† un autre conteneur, on la d√©truit
                    if (this.sidebarCountryMap && this.sidebarCountryMap._container !== mapDiv) {
                        this.sidebarCountryMap.remove();
                        this.sidebarCountryMap = null;
                    }

                    // Initialisation si n√©cessaire
                    if (!this.sidebarCountryMap) {
                        this.sidebarCountryMap = L.map(mapDiv, {
                            center: [20, 0],
                            zoom: 3,
                            zoomControl: false,
                            attributionControl: false
                        });
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            maxZoom: 10
                        }).addTo(this.sidebarCountryMap);
                    }

                    // Recentrage sur le pays si coordonn√©es disponibles
                    if (country && country.coordonnees) {
                        const [lat, lng] = country.coordonnees;
                        this.sidebarCountryMap.setView([lat, lng], 4);
                    }

                    // Correction du bug d'affichage quand on change de contenu dans la sidebar
                    setTimeout(() => {
                        this.sidebarCountryMap.invalidateSize();
                    }, 150);
                }
            }

            buildCountryPersonsInline(countryName) {
                if (!this.personIndex) return '';

                const personsStats = [];

                Object.values(this.personIndex).forEach(p => {
                    const count = (p.events || []).filter(ev =>
                        this.eventBelongsToCountry(ev, countryName)
                    ).length;
                    if (count > 0) {
                        personsStats.push({ nom: p.nom, count });
                    }
                });

                if (!personsStats.length) {
                    return `
                        <section class="timeline-inline-persons">
                            <h4>personnages majeurs.</h4>
                            <p class="no-events">Aucun personnage encore reli√© √† ce pays.</p>
                        </section>
                    `;
                }

                personsStats.sort((a, b) => b.count - a.count);

                return `
                    <section class="timeline-inline-persons">
                        <h4>personnages majeurs.</h4>
                        <div class="detail-persons-list">
                            ${personsStats.slice(0, 20).map(p => `
                                <button class="detail-person-chip timeline-inline-person-chip"
                                        data-person="${p.nom}">
                                    ${p.nom} (${p.count})
                                </button>
                            `).join('')}
                        </div>
                    </section>
                `;
            }

            buildGlobalPersonsInline(events) {
                if (!this.personIndex) return '';

                // On prend tous les personnages et on compte les √©v√®nements
                // (si tu veux vraiment coller au filtre, adapte avec un Set d'√©v√®nements)
                const personsStats = [];

                Object.values(this.personIndex).forEach(p => {
                    const count = (p.events || []).length;
                    if (count > 0) {
                        personsStats.push({ nom: p.nom, count });
                    }
                });

                if (!personsStats.length) {
                    return `
                        <section class="timeline-inline-persons">
                            <h4>personnages majeurs.</h4>
                            <p class="no-events">Aucun personnage encore reli√© √† ces √©v√®nements.</p>
                        </section>
                    `;
                }

                personsStats.sort((a, b) => b.count - a.count);

                return `
                    <section class="timeline-inline-persons">
                        <h4>personnages majeurs.</h4>
                        <div class="detail-persons-list">
                            ${personsStats.slice(0, 30).map(p => `
                                <button class="detail-person-chip timeline-inline-person-chip"
                                        data-person="${p.nom}">
                                    ${p.nom} (${p.count})
                                </button>
                            `).join('')}
                        </div>
                    </section>
                `;
            }

            buildPersonCountriesInline(personName) {
                if (!this.personIndex || !this.personIndex[personName]) {
                    return '';
                }

                const p = this.personIndex[personName];
                const countriesSet = new Set();

                (p.events || []).forEach(ev => {
                    this.eventCountries(ev).forEach(c => countriesSet.add(c));
                });

                const countries = Array.from(countriesSet)
                    .sort((a, b) => a.localeCompare(b, 'fr', { sensitivity: 'base' }));

                if (!countries.length) {
                    return `
                        <section class="timeline-inline-countries">
                            <h4>pays associ√©s.</h4>
                            <p class="no-events">Aucun pays encore reli√© √† ce personnage.</p>
                        </section>
                    `;
                }

                return `
                    <section class="timeline-inline-countries">
                        <h4>pays associ√©s.</h4>
                        <div class="detail-persons-list">
                            ${countries.map(c => `
                                <button class="detail-person-chip timeline-inline-country-chip"
                                        data-country="${c}">
                                    ${c}
                                </button>
                            `).join('')}
                        </div>
                    </section>
                `;
            }
            
            showPersonSheet(personName) {
                const overlay = document.getElementById('detail-overlay');
                const titleEl = document.getElementById('detail-title');
                const subtitleEl = document.getElementById('detail-subtitle');
                const statsEl = document.getElementById('detail-stats');
                const timelineEl = document.getElementById('detail-timeline');
                const personsEl = document.getElementById('detail-persons');
                const personsTitleEl = document.getElementById('detail-persons-title');

                const bioSection = document.getElementById('detail-bio-section');
                const bioEl = document.getElementById('detail-bio');

                if (!overlay || !titleEl || !statsEl || !timelineEl || !personsEl) return;
                if (!this.personIndex || !this.personIndex[personName]) return;

                const p = this.personIndex[personName];

                // √âv√®nements li√©s tri√©s par date
                const events = (p.events || []).slice().sort(
                    (a, b) => new Date(a.date) - new Date(b.date)
                );

                // Pays associ√©s
                const countriesSet = new Set();
                if (Array.isArray(p.paysPrincipaux)) {
                    p.paysPrincipaux.forEach(c => { if (c) countriesSet.add(c); });
                }
                if (countriesSet.size === 0) {
                    events.forEach(ev => {
                        this.eventCountries(ev).forEach(c => countriesSet.add(c));
                    });
                }
                const countriesList = Array.from(countriesSet);

                // Titre
                const displayName = p.titre || p.nom || personName;
                titleEl.textContent = displayName;

                // Sous-titre : fonction + dates de vie format√©es
                const years = events
                    .map(ev => parseInt((ev.date || '').split('-')[0], 10))
                    .filter(y => !isNaN(y));
                const minY = years.length ? Math.min(...years) : null;
                const maxY = years.length ? Math.max(...years) : null;

                const datesLabel = (() => {
                    const birth = p.naissance ? this.formatDateHuman(p.naissance) : '';
                    const death = p.mort ? this.formatDateHuman(p.mort) : '';
                    if (birth && death) return `${birth} ‚Äì ${death}`;
                    if (birth && !death) return `n√©¬∑e ${birth}`;
                    if (!birth && death) return `mort¬∑e ${death}`;
                    return '';
                })();

                const subtitleParts = [];
                if (p.fonction) subtitleParts.push(p.fonction);
                if (datesLabel)  subtitleParts.push(datesLabel);

                if (!subtitleParts.length) {
                    if (events.length) {
                        subtitleParts.push(
                            `‚âà ${events.length} √©v√©nement(s) de ${minY !== null ? minY : '?'} √† ${maxY !== null ? maxY : '?'}`
                        );
                    } else {
                        subtitleParts.push('aucun √©v√©nement enregistr√©.');
                    }
                }
                subtitleEl.textContent = subtitleParts.join(' ‚Ä¢ ');

                // Stats biographiques (inchang√©, sauf si tu veux aussi formater les dates ici)
                let statsHtml = '<div class="detail-stats-grid">';
                if (p.naissance || p.lieuNaissance) {
                    const naissance = p.naissance ? this.formatDateHuman(p.naissance) : '';
                    statsHtml += `
                        <div>
                            <div class="detail-stat-label">naissance</div>
                            <div class="detail-stat-value">
                                ${naissance || ''}${p.lieuNaissance ? ` ‚Äì ${p.lieuNaissance}` : ''}
                            </div>
                        </div>
                    `;
                }
                if (p.mort || p.lieuMort) {
                    const mort = p.mort ? this.formatDateHuman(p.mort) : '';
                    statsHtml += `
                        <div>
                            <div class="detail-stat-label">mort</div>
                            <div class="detail-stat-value">
                                ${mort || ''}${p.lieuMort ? ` ‚Äì ${p.lieuMort}` : ''}
                            </div>
                        </div>
                    `;
                }
                statsHtml += `
                    <div>
                        <div class="detail-stat-label">√©v√©nements li√©s</div>
                        <div class="detail-stat-value">${events.length}</div>
                    </div>
                    <div>
                        <div class="detail-stat-label">pays associ√©s</div>
                        <div class="detail-stat-value">
                            ${countriesList.length ? countriesList.join(', ') : '‚Äì'}
                        </div>
                    </div>
                `;
                statsHtml += '</div>';
                statsEl.innerHTML = statsHtml;

                // üü£ Biographie longue : on privil√©gie bioLongue, puis bioCourte
                if (bioSection && bioEl) {
                    const bio = p.bioLongue || p.bioCourte || '';
                    if (bio) {
                        bioSection.style.display = 'block';
                        // üî• Convertir Markdown ‚Üí HTML avec Marked
                        const rendered = marked.parse(bio);

                        // üî• Injecter le HTML converti
                        bioEl.innerHTML = `
                            <div class="person-bio md-content">
                                ${rendered}
                            </div>
                        `;
                    } else {
                        bioSection.style.display = 'none';
                        bioEl.innerHTML = '';
                    }
                }

                // Chronologie condens√©e : uniquement les √©v√©nements, dates jolies
                if (events.length === 0) {
                    timelineEl.innerHTML = `<p class="no-events">Aucun √©v√©nement √† afficher.</p>`;
                } else {
                    const timelineHtml = events.map(ev => {
                        const lien    = ev.lien && ev.lien !== '#' ? ev.lien : null;
                        const dateStr = ev.date ? this.formatDateHuman(ev.date) : '';
                        const titre   = ev.titre || '(sans titre)';

                        return `
                            <button class="detail-timeline-item"
                                    ${lien ? `data-lien="${lien}"` : ''}>
                                <span class="detail-timeline-date">${dateStr}</span>
                                <span class="detail-timeline-separator">‚Äî</span>
                                <span class="detail-timeline-title">${titre}</span>
                            </button>
                        `;
                    }).join('');
                    timelineEl.innerHTML = timelineHtml;
                }

                // √âv√®nements cliquables -> fiche √©v√®nement
                timelineEl.querySelectorAll('.detail-timeline-item[data-lien]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const url = btn.getAttribute('data-lien');
                        if (url) window.open(url, '_blank');
                    });
                });

                // Pays associ√©s en pastilles
                if (personsTitleEl) {
                    personsTitleEl.textContent = 'pays associ√©s.';
                }

                if (!countriesList.length) {
                    personsEl.innerHTML = `<p class="no-events">Aucun pays encore reli√© √† ce personnage.</p>`;
                } else {
                    personsEl.innerHTML = `
                        <div class="detail-persons-list">
                            ${countriesList
                                .sort((a, b) => a.localeCompare(b, 'fr', { sensitivity: 'base' }))
                                .map(c => `
                                    <button class="detail-person-chip detail-country-chip"
                                            data-country="${c}">
                                        ${c}
                                    </button>
                                `).join('')}
                        </div>
                    `;
                }
                
                // --- Mini-carte centr√©e sur un √©v√©nement du personnage ---
                const mapDiv = document.getElementById('detail-map');
                if (mapDiv) {
                    // Si la mini-carte existante n'est plus attach√©e au bon div, on la recr√©e
                    if (this.detailMap && this.detailMap._container !== mapDiv) {
                        this.detailMap.remove();
                        this.detailMap = null;
                    }

                    if (!this.detailMap) {
                        this.detailMap = L.map(mapDiv, {
                            center: [20, 0],
                            zoom: 3,
                            zoomControl: false,
                            attributionControl: false
                        });
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            maxZoom: 10
                        }).addTo(this.detailMap);
                    }

                    // On cherche un √©v√©nement avec des coordonn√©es [lat, lng]
                    const firstWithCoords = events.find(ev => Array.isArray(ev.coords) && ev.coords.length === 2);
                    if (firstWithCoords) {
                        const [lat, lng] = firstWithCoords.coords;
                        this.detailMap.setView([lat, lng], 4);
                    }

                    setTimeout(() => {
                        this.detailMap.invalidateSize();
                    }, 150);
                }

                // Clic sur un pays li√© = ouvrir la fiche pays (popup)
                personsEl.querySelectorAll('.detail-country-chip').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const country = btn.getAttribute('data-country');
                        if (!country) return;
                        this.showCountrySheet(country);
                    });
                });

                overlay.classList.add('open');
            }

            updateStats() {
                const nbPaysElement = document.getElementById('nb-pays');
                const nbEvenementsElement = document.getElementById('nb-evenements');

                if (!nbPaysElement || !nbEvenementsElement) return;

                let countriesWithEvents = 0;
                let totalEvents = 0;

                // On part des pays d√©j√† filtr√©s par continent
                let filteredCountries = this.cache.countries;
                if (this.selectedContinent !== "tous") {
                    filteredCountries = this.cache.countries.filter(
                        country => country.continent === this.selectedContinent
                    );
                }

                filteredCountries.forEach(country => {
                    // On regarde les √©v√©nements correspondant √† ce pays
                    const eventsForCountry = this.cache.events.filter(ev => {
                        if (!this.eventBelongsToCountry(ev, country.pays)) {
                            return false;
                        }

                        if (this.eventDisplayMode === "all") {
                            return true;
                        }

                        return this.isEventVisibleForYear(ev, this.selectedYear);
                    });

                    if (eventsForCountry.length > 0) {
                        countriesWithEvents++;
                        totalEvents += eventsForCountry.length;
                    }
                });

                // Utiliser l'animation si la m√©thode existe
                if (typeof this.animateNumber === 'function') {
                    this.animateNumber(nbPaysElement, countriesWithEvents);
                    this.animateNumber(nbEvenementsElement, totalEvents);
                } else {
                    nbPaysElement.textContent = countriesWithEvents;
                    nbEvenementsElement.textContent = totalEvents;
                }
            }

            isEventVisibleForYear(event, year) {
                const eventStartYear = parseInt(event.date.split('-')[0]);

                // 1) P√âRIODE D√âTERMIN√âE : visible entre d√©but et fin inclus
                if (event.date_fin) {
                    const eventEndYear = parseInt(event.date_fin.split('-')[0]);
                    return eventStartYear <= year && year <= eventEndYear;
                }

                // 2) PERP√âTUEL : visible √† partir de la date de d√©but
                if (event.perpetuel) {
                    return eventStartYear <= year;
                }

                // 3) PONCTUEL : visible UNIQUEMENT l'ann√©e o√π il a lieu
                return eventStartYear === year;
            }

            eventCountries(event) {
                if (!event || !event.pays) return [];
                return Array.isArray(event.pays) ? event.pays : [event.pays];
            }

            eventBelongsToCountry(event, countryName) {
                const target = countryName.toLowerCase();
                return this.eventCountries(event).some(
                    p => (p || "").toLowerCase() === target
                );
            }

            getEventsForCountry(countryName) {
                return this.cache.events.filter(event => {
                    if (!this.eventBelongsToCountry(event, countryName)) {
                        return false;
                    }

                    if (this.eventDisplayMode === "all") {
                        return true;
                    }

                    return this.isEventVisibleForYear(event, this.selectedYear);
                });
            }
            
            createMarker(country, events) {
                // 1Ô∏è‚É£ V√©rification de base : est-ce qu'on a bien un tableau de 2 √©l√©ments ?
                if (!country.coordonnees || 
                    !Array.isArray(country.coordonnees) || 
                    country.coordonnees.length !== 2) {
                    console.warn(`‚ùå Coordonn√©es invalides pour ${country.pays}:`, country.coordonnees);
                    return;
                }
                
                // 2Ô∏è‚É£ Conversion en nombres (m√™me si c'√©tait des strings)
                const lat = parseFloat(country.coordonnees[0]);
                const lng = parseFloat(country.coordonnees[1]);
                
                // 3Ô∏è‚É£ V√©rification que la conversion a fonctionn√©
                if (isNaN(lat) || isNaN(lng)) {
                    console.warn(`‚ùå Impossible de convertir en nombres pour ${country.pays}: [${country.coordonnees[0]}, ${country.coordonnees[1]}]`);
                    return;
                }
                
                // 4Ô∏è‚É£ V√©rification que les coordonn√©es sont r√©alistes
                if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    console.warn(`‚ùå Coordonn√©es hors limites pour ${country.pays}: [${lat}, ${lng}]`);
                    return;
                }

                const iconSize = Math.min(15 + events.length * 2, 30);
                const customIcon = L.divIcon({
                    html: `<div style="
                        width: ${iconSize}px;
                        height: ${iconSize}px;
                        background: var(--couleur-accent);
                        border: 3px solid white;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: ${Math.max(8, iconSize/3)}px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    ">${events.length}</div>`,
                    className: 'custom-marker',
                    iconSize: [iconSize, iconSize],
                    iconAnchor: [iconSize/2, iconSize/2]
                });
                
                // Contenu affich√© en survol (tooltip)
                let hoverContent = `
                    <div style="min-width: 220px;">
                        <h3 style="margin: 0 0 8px 0; color: var(--couleur-accent); font-size: 0.95rem;">
                            ${country.pays}
                        </h3>
                        <p style="margin: 0 0 6px 0; font-size: 0.8rem;">
                            <strong>${events.length}</strong> √©v√©nement(s)
                        </p>
                `;
                
                events.slice(0, 3).forEach(event => {
                    const categoryIcon = this.getCategoryIcon(event.categorie);
                    const dateStr      = this.formatDateHuman(event.date);

                    hoverContent += `
                        <div style="margin: 4px 0; padding: 6px 8px; background: rgba(15,23,42,0.05); border-radius: 6px;">
                            <div style="font-size: 0.78rem; opacity: 0.9; margin-bottom: 2px;">
                                ${categoryIcon} ${dateStr}
                            </div>
                            <div style="font-size: 0.8rem; font-weight: 600;">
                                ${event.titre}
                            </div>
                        </div>
                    `;
                });
                
                if (events.length > 3) {
                    hoverContent += `<p style="margin: 4px 0 0 0; font-size: 0.75rem; opacity: 0.8;">
                        ‚Ä¶ et ${events.length - 3} autre(s)
                    </p>`;
                }
                hoverContent += '</div>';
                
                const marker = L.marker([lat, lng], { icon: customIcon })
                    .addTo(this.markers);
                
                // Tooltip au survol au lieu du popup au clic
                marker.bindTooltip(hoverContent, {
                    direction: 'top',
                    sticky: true,
                    opacity: 0.95,
                    className: 'marker-tooltip'
                });
                
                // Clic = fiche pays dans la sidebar
                marker.on('click', () => {
                    const sidebarEl = document.getElementById('sidebar');
                    if (sidebarEl) {
                        sidebarEl.classList.remove('collapsed'); // au cas o√π elle est ferm√©e
                    }
                    if (typeof this.showCountrySidebarSheet === 'function') {
                        this.showCountrySidebarSheet(country.pays);
                    }
                });

                this.markers[country.pays] = marker;
            }
            
            getCategoryIcon(category) {
                const icons = {
                    'politique': 'üèõÔ∏è',
                    'science': 'üî¨',
                    'social': 'üë•',
                    'economie': 'üí∞',
                    'culture': 'üé®',
                    'guerre': '‚öîÔ∏è',
                    'default': 'üìÖ'
                };
                return icons[category] || icons.default;
            }
            
            showTimeline(countryName) {
                this.currentTimelineContext = {
                    type: 'country',
                    name: countryName
                };

                const timelineContent = document.getElementById('timeline-content');
                const timeline = document.getElementById('timeline');

                if (!timelineContent || !timeline) return;

                timeline.classList.remove('collapsed');
                const toggleBtn = document.getElementById('toggle-timeline');
                if (toggleBtn) toggleBtn.textContent = '‚ñº';

                let events = this.cache.events
                    .filter(ev => this.eventBelongsToCountry(ev, countryName))
                    .sort((a, b) => new Date(a.date) - new Date(b.date));

                events = this.filterEventsByTimelinePeriod(events);

                if (!events.length) {
                    timelineContent.innerHTML = `
                        <h3 class="timeline-section-title">üìú Timeline ‚Äì ${countryName}</h3>
                        <p>Aucun √©v√©nement trouv√© pour ${countryName}.</p>
                    `;
                    this.drawTimeline([]);
                    return;
                }

                // frise locale (en bas de l‚Äô√©cran carte)
                this.drawTimeline(events);

                // liste structur√©e par si√®cle + personnages au-dessus
                const title = `üìú Timeline ‚Äì ${countryName}`;
                const personsInlineHtml = this.buildCountryPersonsInline(countryName);

                timelineContent.innerHTML = this.buildTimelineList(events, {
                    title,
                    showCountries: false,
                    showMiniMap: false,                    // üëâ on d√©sactive la mini-map
                    extraSummaryFooterHtml: personsInlineHtml // üëâ on met la liste des personnages
                });

                this.currentTimelineEvents = events;
                this.setupTimelineListInteractions(timelineContent, events, 'country');
            }


            drawTimeline(events) {
                const track = document.getElementById("timeline-track");
                if (!track) return;

                track.innerHTML = "";
                this.timelineDots = [];
                this.currentTimelineEvents = events || [];
                this.selectedTimelineIndex = null;

                if (!events || events.length === 0) return;

                const years = (events || [])
                    .map(ev => {
                        if (!ev.date || typeof ev.date !== "string") return NaN;
                        const yearStr = ev.date.split("-")[0];
                        const year = parseInt(yearStr, 10);
                        return isNaN(year) ? NaN : year;
                    })
                    .filter(y => !isNaN(y));

                if (years.length === 0) return;

                const maxYearEvents = Math.max(...years);

                // üïí Ann√©e "aujourd'hui"
                const currentYear = 2024;

                // On veut que l'axe aille au moins jusqu'√† aujourd'hui
                const finalMaxYear = Math.max(maxYearEvents, currentYear);

                // üß≠ D√©but de la timeline TOUJOURS √† -500
                const start = -500;
                const end   = Math.ceil(finalMaxYear / 100) * 100;
                const visibleYears = end - start || 100;

                // üéØ Objectif : ~1000 ans visibles √† l'√©cran pour zoom = 1
                const trackWidth = track.clientWidth || 800;
                const yearsPerScreen = 1000;
                let pxPerYear = (trackWidth / (yearsPerScreen * this.timelineZoom));

                const MIN = 0.5;
                const MAX = 30;
                pxPerYear = Math.max(MIN, Math.min(MAX, pxPerYear));

                const totalWidth = visibleYears * pxPerYear;

                // Conteneur interne
                const inner = document.createElement("div");
                inner.className = "timeline-track-inner";
                inner.style.width = totalWidth + "px";
                track.appendChild(inner);

                // Axe
                const axis = document.createElement("div");
                axis.className = "timeline-axis";
                axis.style.width = totalWidth + "px";
                inner.appendChild(axis);

                // Rep√®res d'ann√©es tous les 50 ans
                for (let y = start; y <= end; y += 50) {
                    const label = document.createElement("div");
                    label.className = "timeline-year";
                    label.textContent = y;
                    const x = (y - start) * pxPerYear;
                    label.style.left = x + "px";
                    inner.appendChild(label);
                }

                // Tooltip unique
                const tooltip = document.createElement("div");
                tooltip.className = "timeline-tooltip";
                inner.appendChild(tooltip);

                const dots = [];

                events.forEach((ev, index) => {
                    if (!ev.date || typeof ev.date !== "string") return;

                    const yearStr = ev.date.split("-")[0];
                    const year = parseInt(yearStr, 10);
                    if (isNaN(year)) return;

                    const xPos = (year - start) * pxPerYear;
                    const dot = document.createElement("div");
                    dot.className = "timeline-dot";
                    dot.style.left = xPos + "px";

                    const description = `${ev.date} ‚Äî ${ev.titre}`;

                    dot.addEventListener("mouseenter", () => {
                        tooltip.textContent = description;
                        tooltip.style.left = xPos + "px";
                        tooltip.classList.add("visible");
                    });

                    dot.addEventListener("mouseleave", () => {
                        tooltip.classList.remove("visible");
                    });

                    dot.addEventListener("click", () => {
                        this.focusTimelineEvent(index);
                    });

                    dots.push(dot);
                    inner.appendChild(dot);
                });

                this.timelineDots = dots;

                // ‚úÖ s√©lectionner automatiquement le premier √©v√©nement
                if (dots.length > 0) {
                    this.focusTimelineEvent(0);
                }

                // Zoom + pan √† la molette
                track.onwheel = (e) => {
                    e.preventDefault();

                    // Shift + molette = scroll horizontal (pan)
                    if (e.shiftKey) {
                        track.scrollLeft += e.deltaY; // inverse si tu pr√©f√®res l‚Äôautre sens
                        return;
                    }

                    // Sinon : zoom temporel
                    if (e.deltaY > 0) {
                        // d√©-zoom
                        this.timelineZoom = Math.max(this.timelineMinZoom, this.timelineZoom / 1.6);
                    } else {
                        // zoom
                        this.timelineZoom = Math.min(this.timelineMaxZoom, this.timelineZoom * 1.6);
                    }

                    this.drawTimeline(this.currentTimelineEvents);

                    if (this.selectedTimelineIndex !== null) {
                        this.focusTimelineEvent(this.selectedTimelineIndex);
                    }
                };

                // Click & drag pour faire d√©filer la timeline
                let isDragging = false;
                let startX = 0;
                let startScrollLeft = 0;

                track.onmousedown = (e) => {
                    isDragging = true;
                    track.classList.add('dragging');
                    startX = e.clientX;
                    startScrollLeft = track.scrollLeft;
                };

                track.onmouseleave = () => {
                    isDragging = false;
                    track.classList.remove('dragging');
                };

                track.onmouseup = () => {
                    isDragging = false;
                    track.classList.remove('dragging');
                };

                track.onmousemove = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    const dx = e.clientX - startX;
                    track.scrollLeft = startScrollLeft - dx;
                };
            }

            showGlobalTimeline() {
                const track = document.getElementById('timeline-global-track');
                const content = document.getElementById('timeline-global-content');
                if (!track || !content) return;

                let events = [];

                if (this.eventDisplayMode === "all") {
                    events = this.cache.events.slice();
                } else {
                    events = this.cache.events.filter(ev =>
                        this.isEventVisibleForYear(ev, this.selectedYear)
                    );
                }

                if (this.selectedContinent !== "tous") {
                    const countriesInContinent = this.cache.countries
                        .filter(country => country.continent === this.selectedContinent)
                        .map(country => country.pays.toLowerCase());

                    events = events.filter(ev =>
                        countriesInContinent.includes(ev.pays.toLowerCase())
                    );
                }

                events = this.filterEventsByTimelinePeriod(events);

                if (!events.length) {
                    track.innerHTML = "";
                    content.innerHTML = `<p>Aucun √©v√©nement √† afficher en chronologie mondiale.</p>`;
                    return;
                }

                // tri chronologique
                events.sort((a, b) => new Date(a.date) - new Date(b.date));

                // zoom automatique de la frise
                this.autoAdjustGlobalTimelineZoom(events);

                // frise
                this.drawGlobalTimeline(events);

                // liste √©pur√©e + mini r√©sum√© + liste des personnages (pas de mini-carte)
                const title = `üåç Chronologie mondiale (${events.length} √©v√©nement(s))`;
                content.innerHTML = this.buildTimelineList(events, {
                    title,
                    showCountries: true,
                    showMiniMap: false,
                    extraSummaryFooterHtml: this.buildGlobalPersonsInline(events)
                });

                // interactions (pliage des si√®cles, clic pour focus‚Ä¶)
                this.setupTimelineListInteractions(content, events, 'world');
            }

            drawGlobalTimeline(events) {
                const track = document.getElementById("timeline-global-track");
                if (!track) return;

                track.innerHTML = "";
                this.timelineGlobalDots = [];
                this.currentGlobalTimelineEvents = events || [];
                this.selectedGlobalTimelineIndex = null;

                if (!events || events.length === 0) return;

                const years = (events || [])
                    .map(ev => {
                        if (!ev.date || typeof ev.date !== "string") return NaN;
                        const yearStr = ev.date.split("-")[0];
                        const year = parseInt(yearStr, 10);
                        return isNaN(year) ? NaN : year;
                    })
                    .filter(y => !isNaN(y));

                const maxYearEvents = Math.max(...years);

                // üïí ann√©e "aujourd'hui"
                const currentYear = 2024;

                // l‚Äôaxe doit au moins aller jusqu‚Äô√† aujourd‚Äôhui
                const finalMaxYear = Math.max(maxYearEvents, currentYear);

                // üß≠ d√©but toujours √† -500 pour la timeline mondiale
                const start = -500;
                const end   = Math.ceil(finalMaxYear / 100) * 100;
                const visibleYears = end - start || 100;

                // üéØ ~1000 ans visibles √† l‚Äô√©cran pour zoom = 1
                const trackWidth = track.clientWidth || 800;
                const yearsPerScreen = 1000;
                let pxPerYear = trackWidth / (yearsPerScreen * this.timelineGlobalZoom);

                const MIN = 0.5;
                const MAX = 30;
                pxPerYear = Math.max(MIN, Math.min(MAX, pxPerYear));

                const totalWidth = visibleYears * pxPerYear;

                const inner = document.createElement("div");
                inner.className = "timeline-track-inner";
                inner.style.width = totalWidth + "px";
                track.appendChild(inner);

                // Axe
                const axis = document.createElement("div");
                axis.className = "timeline-axis";
                axis.style.width = totalWidth + "px";
                inner.appendChild(axis);

                // Rep√®res tous les 50 ans
                for (let y = start; y <= end; y += 50) {
                    const label = document.createElement("div");
                    label.className = "timeline-year";
                    label.textContent = y;
                    const x = (y - start) * pxPerYear;
                    label.style.left = x + "px";
                    inner.appendChild(label);
                }

                // Tooltip unique
                const tooltip = document.createElement("div");
                tooltip.className = "timeline-tooltip";
                inner.appendChild(tooltip);

                const dots = [];

                events.forEach((ev, index) => {
                    if (!ev.date || typeof ev.date !== "string") return;

                    const yearStr = ev.date.split("-")[0];
                    const year = parseInt(yearStr, 10);
                    if (isNaN(year)) return;

                    const xPos = (year - start) * pxPerYear;
                    const dot = document.createElement("div");
                    dot.className = "timeline-dot";
                    dot.style.left = xPos + "px";

                    const description = `${ev.date} ‚Äì ${Array.isArray(ev.pays) ? ev.pays.join(", ") : ev.pays} ‚Äì ${ev.titre}`;

                    dot.addEventListener("mouseenter", () => {
                        tooltip.textContent = description;
                        tooltip.style.left = xPos + "px";
                        tooltip.classList.add("visible");
                    });

                    dot.addEventListener("mouseleave", () => {
                        tooltip.classList.remove("visible");
                    });

                    dot.addEventListener("click", () => {
                        this.focusGlobalTimelineEvent(index);
                    });

                    dots.push(dot);
                    inner.appendChild(dot);
                });

                this.timelineGlobalDots = dots;
                this.currentGlobalTimelineEvents = events;

                if (dots.length > 0) {
                    this.focusGlobalTimelineEvent(0);
                }

                // Brancher les fl√®ches ‚óÄ ‚ñ∂ pour la timeline mondiale
                const prev = document.getElementById("timeline-global-prev");
                const next = document.getElementById("timeline-global-next");
                if (prev && next) {
                    prev.onclick = () => this.moveGlobalTimeline(-1);
                    next.onclick = () => this.moveGlobalTimeline(1);
                }

                track.onwheel = (e) => {
                    e.preventDefault();

                    // Shift + molette = pan horizontal
                    if (e.shiftKey) {
                        track.scrollLeft += e.deltaY;
                        return;
                    }

                    // Sinon : zoom global
                    if (e.deltaY > 0) {
                        this.timelineGlobalZoom = Math.max(
                            this.timelineGlobalMinZoom,
                            this.timelineGlobalZoom / 1.2
                        );
                    } else {
                        this.timelineGlobalZoom = Math.min(
                            this.timelineGlobalMaxZoom,
                            this.timelineGlobalZoom * 1.2
                        );
                    }

                    this.drawGlobalTimeline(this.currentGlobalTimelineEvents);

                    if (this.selectedGlobalTimelineIndex !== null) {
                        this.focusGlobalTimelineEvent(this.selectedGlobalTimelineIndex);
                    }

                    let isDragging = false;
                    let startX = 0;
                    let startScrollLeft = 0;

                    track.onmousedown = (e) => {
                        isDragging = true;
                        track.classList.add('dragging');
                        startX = e.clientX;
                        startScrollLeft = track.scrollLeft;
                    };

                    track.onmouseleave = () => {
                        isDragging = false;
                        track.classList.remove('dragging');
                    };

                    track.onmouseup = () => {
                        isDragging = false;
                        track.classList.remove('dragging');
                    };

                    track.onmousemove = (e) => {
                        if (!isDragging) return;
                        e.preventDefault();
                        const dx = e.clientX - startX;
                        track.scrollLeft = startScrollLeft - dx;
                    };
                };
            }
            
            refreshCurrentTimelineView() {
                const activeTab = document.querySelector('.timeline-tab.active');
                const mode = activeTab ? activeTab.dataset.mode : 'country';

                if (mode === 'world') {
                    this.showGlobalTimeline();
                    return;
                }

                if (mode === 'country') {
                    const current = this.currentTimelineContext && this.currentTimelineContext.type === 'country'
                        ? this.currentTimelineContext.name
                        : null;

                    const select = document.getElementById('timeline-country-select');
                    const name = current || (select && select.value) || null;

                    if (name) this.showTimeline(name);
                    return;
                }

                if (mode === 'person') {
                    const current = this.currentTimelineContext && this.currentTimelineContext.type === 'person'
                        ? this.currentTimelineContext.name
                        : null;

                    const select = document.getElementById('timeline-person-select');
                    const name = current || (select && select.value) || null;

                    if (name) this.showPersonTimeline(name);
                    return;
                }
            }

            focusGlobalTimelineEvent(index) {
                const track = document.getElementById('timeline-global-track');
                if (!track || !this.timelineGlobalDots || this.timelineGlobalDots.length === 0) return;

                if (index < 0 || index >= this.timelineGlobalDots.length) return;

                this.selectedGlobalTimelineIndex = index;

                this.timelineGlobalDots.forEach(dot => dot.classList.remove('selected'));

                const dot = this.timelineGlobalDots[index];
                if (!dot) return;

                dot.classList.add('selected');

                const trackWidth = track.clientWidth || 0;
                const xPos = dot.offsetLeft;
                const targetScrollLeft = xPos - trackWidth / 2;
                track.scrollTo({
                    left: Math.max(0, targetScrollLeft),
                    behavior: 'smooth'
                });

                // Faire d√©filer la liste texte correspondante
                const content = document.getElementById('timeline-global-content');
                if (content) {
                    const card = content.querySelector(`.timeline-event[data-global-index="${index}"]`);
                    if (card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        card.classList.add('highlight');
                        setTimeout(() => card.classList.remove('highlight'), 1500);
                    }
                }
            }

            moveGlobalTimeline(delta) {
                if (!this.timelineGlobalDots || this.timelineGlobalDots.length === 0) return;

                let index = (this.selectedGlobalTimelineIndex !== null)
                    ? this.selectedGlobalTimelineIndex
                    : 0;

                index += delta;

                if (index < 0) index = 0;
                if (index >= this.timelineGlobalDots.length) {
                    index = this.timelineGlobalDots.length - 1;
                }

                this.focusGlobalTimelineEvent(index);
            }

            focusTimelineEvent(index) {
                const track = document.getElementById('timeline-track');
                if (!track || !this.timelineDots || this.timelineDots.length === 0) return;

                if (index < 0 || index >= this.timelineDots.length) return;

                // Mettre √† jour l'index s√©lectionn√©
                this.selectedTimelineIndex = index;

                // Nettoyer la s√©lection pr√©c√©dente
                this.timelineDots.forEach(dot => dot.classList.remove('selected'));

                const dot = this.timelineDots[index];
                if (!dot) return;

                // Appliquer l'√©tat s√©lectionn√©
                dot.classList.add('selected');

                // Centrer le point dans la frise
                const trackWidth = track.clientWidth || 0;
                const xPos = dot.offsetLeft;
                const targetScrollLeft = xPos - trackWidth / 2;
                track.scrollTo({
                    left: Math.max(0, targetScrollLeft),
                    behavior: 'smooth'
                });

                // Faire d√©filer la liste vers l'√©v√®nement correspondant
                const target = document.getElementById(`timeline-event-${index}`);
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    target.classList.add('highlight');
                    setTimeout(() => target.classList.remove('highlight'), 1500);
                }
            }

            moveTimeline(delta) {
                if (!this.timelineDots || this.timelineDots.length === 0) return;

                let index = (this.selectedTimelineIndex !== null)
                    ? this.selectedTimelineIndex
                    : 0;

                index += delta;

                // On bloque au d√©but / √† la fin
                if (index < 0) index = 0;
                if (index >= this.timelineDots.length) index = this.timelineDots.length - 1;

                this.focusTimelineEvent(index);
            }  

            updateEventsList() {
                const eventsList = document.getElementById('events-list');
                let currentYearEvents = [];

                if (this.eventDisplayMode === "all") {
                    // Mode "Tous les √©v√©nements" : afficher TOUS les √©v√©nements de TOUTES les ann√©es
                    currentYearEvents = [...this.cache.events];
                    
                    // Filtrer par continent uniquement (pas d'ann√©e)
                    if (this.selectedContinent !== "tous") {
                        const countriesInContinent = this.cache.countries
                            .filter(country => country.continent === this.selectedContinent)
                            .map(country => country.pays.toLowerCase());
                        
                        currentYearEvents = currentYearEvents.filter(event => {
                            const eventCountries = this.eventCountries(event).map(p => p.toLowerCase());
                            return eventCountries.some(p => countriesInContinent.includes(p));
                        });
                    }
                } else {
                    // Mode "Ann√©e courante" : filtrer les √©v√©nements pour l'ann√©e s√©lectionn√©e
                    currentYearEvents = this.cache.events.filter(event => 
                        this.isEventVisibleForYear(event, this.selectedYear)
                    );

                    // Filtrer par continent si n√©cessaire
                    if (this.selectedContinent !== "tous") {
                        const countriesInContinent = this.cache.countries
                            .filter(country => country.continent === this.selectedContinent)
                            .map(country => country.pays.toLowerCase());
                        
                        currentYearEvents = currentYearEvents.filter(event => {
                            const eventCountries = this.eventCountries(event).map(p => p.toLowerCase());
                            return eventCountries.some(p => countriesInContinent.includes(p));
                        });
                    }
                }
                
                if (currentYearEvents.length === 0) {
                    const message = this.eventDisplayMode === "all" 
                        ? 'Aucun √©v√©nement trouv√©' 
                        : 'Aucun √©v√©nement pour cette ann√©e';
                    eventsList.innerHTML = `<p class="no-events">${message}</p>`;
                    return;
                }

                // Trier par date
                currentYearEvents.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                let html = '';
                currentYearEvents.forEach(event => {
                    const categoryIcon = this.getCategoryIcon(event.categorie);
                    
                    const dateStr = this.formatDateHuman(event.date);

                    html += `
                        <div class="event-item" onclick="historicalMap.focusOnCountry('${event.pays}')">
                            <div class="event-date">${categoryIcon} ${dateStr}</div>
                            <div class="event-title">${event.titre}</div>
                            <div class="event-country">${event.pays}</div>
                        </div>
                    `;
                });
                
                eventsList.innerHTML = html;
            }

            updateNotesList() {
                const notesContainer = document.getElementById('notes-list');
                if (!notesContainer) return;

                const notes = Array.isArray(this.cache.notes) ? [...this.cache.notes] : [];

                if (!notes.length) {
                    notesContainer.innerHTML = '<p class="no-events">Aucune note.</p>';
                    return;
                }

                notes.sort((a, b) => {
                    const ta = (a.titre || a.title || '').toString();
                    const tb = (b.titre || b.title || '').toString();
                    return ta.localeCompare(tb, 'fr', { sensitivity: 'base' });
                });

                let html = '';
                notes.forEach((note, index) => {
                    const titre = note.titre || note.title || '(sans titre)';
                    const date  = note.date ? this.formatDateHuman(note.date) : '';
                    const pays  = Array.isArray(note.pays) ? note.pays.join(', ') : (note.pays || '');

                    html += `
                        <div class="event-item note-item" data-note-index="${index}">
                            ${date ? `<div class="event-date">üóíÔ∏è ${date}</div>` : '<div class="event-date">üóíÔ∏è note</div>'}
                            <div class="event-title">${titre}</div>
                            ${pays ? `<div class="event-country">${pays}</div>` : ''}
                        </div>
                    `;
                });

                notesContainer.innerHTML = html;

                notesContainer.querySelectorAll('.note-item').forEach(el => {
                    el.addEventListener('click', () => {
                        const indexStr = el.getAttribute('data-note-index');
                        const idx = parseInt(indexStr, 10);
                        const note = notes[idx];
                        this.openNote(note);
                    });
                });
            }

            renderNotesPanel() {
                const grid = document.getElementById('notes-tab-list');
                if (!grid) return;

                const notes = Array.isArray(this.cache.notes) ? [...this.cache.notes] : [];

                if (!notes.length) {
                    grid.innerHTML = '<p class="no-events">Aucune note.</p>';
                    return;
                }

                notes.sort((a, b) => {
                    const ta = (a.titre || a.title || '').toString();
                    const tb = (b.titre || b.title || '').toString();
                    return ta.localeCompare(tb, 'fr', { sensitivity: 'base' });
                });

                grid.innerHTML = notes.map((note, index) => {
                    const titre = note.titre || note.title || '(sans titre)';
                    const date  = note.date ? this.formatDateHuman(note.date) : '';
                    const pays  = Array.isArray(note.pays) ? note.pays.join(', ') : (note.pays || '');
                    const desc  = (note.description || '').toString().slice(0, 220);

                    return `
                        <article class="note-card" data-note-index="${index}">
                            <div class="note-title">${titre}</div>
                            <div class="note-meta">
                                ${date ? `<span>${date}</span>` : '<span>note</span>'}
                                ${pays ? `<span class="directory-chip">${pays}</span>` : ''}
                            </div>
                            ${desc ? `<div class="note-description">${desc}</div>` : ''}
                        </article>
                    `;
                }).join('');

                grid.querySelectorAll('.note-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const idx = parseInt(card.getAttribute('data-note-index'), 10);
                        const note = notes[idx];
                        this.openNote(note);
                    });
                });
            }

            openNote(note) {
                if (!note) return;

                // Si des coordonn√©es sont disponibles, on centre la carte pour situer la note
                if (Array.isArray(note.coords) && note.coords.length === 2 && this.map) {
                    this.map.setView(note.coords, 6);
                }

                const url = note.lien || note.url || note.link;
                if (url && url !== '#') {
                    window.location.href = url;
                    return;
                }

                // Pas de lien : on affiche simplement un rappel
                const titre = note.titre || note.title || 'note';
                this.showNotification(`üìÑ ${titre} (aucun lien disponible)`, 'info');
            }

            focusOnCountry(countryName) {
                // Trouver le pays
                const country = this.cache.countries.find(c => 
                    c.pays.toLowerCase() === countryName.toLowerCase()
                );
                
                if (country && country.coordonnees) {
                    // Centrer la carte sur le pays
                    this.map.setView(country.coordonnees, 6);
                    
                    // Montrer les √©v√©nements du pays dans la timeline
                    const events = this.cache.events
                    .filter(ev => this.eventBelongsToCountry(ev, country.pays))
                    .sort((a, b) => new Date(a.date) - new Date(b.date));
                    this.showTimeline(country.pays, events);
                    
                    // Fermer la sidebar sur mobile
                    if (window.innerWidth <= 768) {
                        document.getElementById('sidebar').classList.add('collapsed');
                    }
                }
            }
                        
                        animateNumber(element, targetValue) {
                            const currentValue = parseInt(element.textContent) || 0;
                            const increment = Math.ceil((targetValue - currentValue) / 10);
                            
                            if (currentValue !== targetValue) {
                                element.textContent = Math.max(0, currentValue + increment);
                                setTimeout(() => this.animateNumber(element, targetValue), 50);
                            } else {
                                element.textContent = targetValue;
                            }
                        }
            
            // ========================================
            // FONCTIONS SYNCHRONISATION OBSIDIAN
            // ========================================
            
            async triggerSync() {
                this.setSyncStatus('syncing', 'Synchronisation...');
                this.showNotification('üîÑ Synchronisation en cours...', 'info');
                
                try {
                    // Simplement recharger les donn√©es depuis les fichiers JSON locaux
                    await this.loadData(true);
                    this.setSyncStatus('success', 'Synchronis√©');
                    this.showNotification('‚úÖ Donn√©es recharg√©es', 'success');
        
                    // Mettre √† jour l'affichage de la derni√®re sync
                    this.cache.lastSync = new Date();
                    this.updateLastSyncDisplay();

                } catch (error) {
                    console.error("‚ùå Erreur de synchronisation:", error);
                    this.setSyncStatus('error', 'Erreur sync');
                    this.showNotification('‚ùå Erreur de synchronisation', 'error');
                }
            }
            
            toggleWatch() {
                this.watchMode = !this.watchMode;
                const button = document.getElementById('watch-toggle');
                
                if (this.watchMode) {
                    button.textContent = 'üëÅÔ∏è Stop';
                    button.style.background = 'rgba(239, 68, 68, 0.2)';
                    this.startPolling(5000); // Poll plus fr√©quent
                    this.showNotification('üëÅÔ∏è Surveillance activ√©e', 'success');
                } else {
                    button.textContent = 'üëÅÔ∏è Watch';
                    button.style.background = 'rgba(255, 255, 255, 0.2)';
                    this.startPolling(30000); // Poll normal
                    this.showNotification('‚èπÔ∏è Surveillance d√©sactiv√©e', 'info');
                }
            }
            
            startPolling(interval = 30000) {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                }
                
                this.pollInterval = setInterval(() => {
                    this.checkForUpdates();
                }, interval);
            }
            
            async checkForUpdates() {
                // Mode local - pas de v√©rification serveur
                console.debug("Mode local actif - pas de v√©rification serveur");
                return;
            }
            
            setSyncStatus(status, text) {
                const indicator = document.getElementById('sync-indicator');
                const statusText = indicator.querySelector('span');
                
                indicator.className = `sync-indicator ${status}`;
                statusText.textContent = text;
            }
            
            updateLastSyncDisplay() {
                const lastSyncElement = document.getElementById('last-sync');
                if (this.cache.lastSync) {
                    const time = this.cache.lastSync.toLocaleTimeString('fr-FR', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    lastSyncElement.textContent = time;
                } else {
                    lastSyncElement.textContent = 'Jamais';
                }
            }
            
            // ========================================
            // FONCTIONS UTILITAIRES
            // ========================================
            
            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                
                if (this.isDarkTheme) {
                    document.body.classList.add('theme-sombre');
                } else {
                    document.body.classList.remove('theme-sombre');
                }
                
                localStorage.setItem('theme-sombre', this.isDarkTheme);
            }
            
            showLoading(show) {
                const overlay = document.getElementById('loading-overlay');
                if (show) {
                    overlay.classList.add('show');
                } else {
                    overlay.classList.remove('show');
                }
            }
            
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => notification.classList.add('show'), 10);
                
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => document.body.removeChild(notification), 300);
                }, 3000);
            }
            
            // Formate une date "YYYY", "YYYY-MM", "YYYY-MM-DD" en fran√ßais
            // ex. "2012-12-01" -> "1er d√©cembre 2012"
            formatDateHuman(dateStr) {
                if (!dateStr) return '';
                if (typeof dateStr !== 'string') {
                    dateStr = String(dateStr);
                }
                const cleaned = dateStr.trim();
                if (!cleaned) return '';

                const match = cleaned.match(/^(-?\d{1,4})(?:-(\d{1,2})(?:-(\d{1,2}))?)?$/);
                if (!match) {
                    // Format exotique : on renvoie brut
                    return cleaned;
                }

                let year  = parseInt(match[1], 10);
                const month = match[2] ? parseInt(match[2], 10) : null;
                const day   = match[3] ? parseInt(match[3], 10) : null;

                const monthNames = [
                    'janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin',
                    'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'
                ];

                const isBC = year <= 0;
                if (isBC) {
                    year = Math.abs(year);
                }

                let result;
                if (month && day) {
                    const dayStr   = (day === 1) ? '1er' : String(day);
                    const monthStr = monthNames[month - 1] || '';
                    result = `${dayStr} ${monthStr} ${year}`;
                } else if (month) {
                    const monthStr = monthNames[month - 1] || '';
                    result = `${monthStr} ${year}`;
                } else {
                    result = `${year}`;
                }

                if (isBC) {
                    result += ' av. J.-C.';
                }

                return result;
            }

            // Pr√©pare la petite ligne de meta pour un personnage (dates de vie ou borne des √©v√©nements)
            formatPersonMeta(person) {
                if (!person) return '';

                const parts = [];

                if (person.naissance || person.mort) {
                    const birth = person.naissance ? this.formatDateHuman(person.naissance) : '';
                    const death = person.mort ? this.formatDateHuman(person.mort) : '';

                    if (birth && death) {
                        parts.push(`${birth} ‚Äì ${death}`);
                    } else if (birth) {
                        parts.push(`n√©¬∑e ${birth}`);
                    } else if (death) {
                        parts.push(`‚úù ${death}`);
                    }
                }

                // √Ä d√©faut, on prend la p√©riode couverte par ses √©v√©nements
                if (parts.length === 0 && Array.isArray(person.events) && person.events.length) {
                    const years = person.events
                        .map(ev => this.getEventYear(ev))
                        .filter(y => y != null)
                        .sort((a, b) => a - b);

                    if (years.length) {
                        const first = years[0];
                        const last  = years[years.length - 1];
                        parts.push(first === last ? `${first}` : `${first} ‚Äì ${last}`);
                    }
                }

                return parts.join(' ¬∑ ');
            }

            // Met √† jour la liste des r√©sultats de la barre de recherche globale
            updateGlobalSearchResults(query) {
                const input     = document.getElementById('global-search-input');
                const container = document.getElementById('global-search-results');
                if (!input || !container) return;

                const trimmed = (query || '').trim();
                if (trimmed.length < 2) {
                    container.innerHTML = '';
                    container.classList.remove('open');
                    return;
                }

                const q = trimmed.toLowerCase();

                // √âv√©nements : filtre sur le titre
                const events = (this.cache.events || []).filter(ev => {
                    const title = (ev.titre || '').toString().toLowerCase();
                    return title.includes(q);
                });

                // Personnages : filtre sur le nom
                const persons = Object.values(this.personIndex || {}).filter(p => {
                    const name = (p.nom || '').toString().toLowerCase();
                    return name.includes(q);
                });

                if (!events.length && !persons.length) {
                    container.innerHTML = `<div class="global-search-empty">Aucun r√©sultat</div>`;
                    container.classList.add('open');
                    return;
                }

                const maxEvents  = 15;
                const maxPersons = 15;

                let html = '<div class="global-search-groups">';

                // Groupe √âV√âNEMENTS
                if (events.length) {
                    html += `
                        <div class="global-search-group">
                            <div class="global-search-group-title">√©v√©nements</div>
                            <ul class="global-search-list">
                    `;
                    events.slice(0, maxEvents).forEach(ev => {
                        const title   = ev.titre || '(sans titre)';
                        const dateStr = ev.date ? this.formatDateHuman(ev.date) : '';
                        const lien    = ev.lien && ev.lien !== '#' ? ev.lien : '';

                        html += `
                            <li>
                                <button type="button"
                                        class="global-search-item"
                                        data-type="event"
                                        ${lien ? `data-lien="${lien}"` : ''}>
                                    <span class="global-search-item-title">${title}</span>
                                    ${dateStr ? `<span class="global-search-item-meta">${dateStr}</span>` : ''}
                                </button>
                            </li>
                        `;
                    });
                    html += `
                            </ul>
                        </div>
                    `;
                }

                // Groupe PERSONNAGES
                if (persons.length) {
                    html += `
                        <div class="global-search-group">
                            <div class="global-search-group-title">personnages</div>
                            <ul class="global-search-list">
                    `;
                    persons.slice(0, maxPersons).forEach(p => {
                        const meta = this.formatPersonMeta(p);
                        html += `
                            <li>
                                <button type="button"
                                        class="global-search-item"
                                        data-type="person"
                                        data-person="${p.nom}">
                                    <span class="global-search-item-title">${p.nom}</span>
                                    ${meta ? `<span class="global-search-item-meta">${meta}</span>` : ''}
                                </button>
                            </li>
                        `;
                    });
                    html += `
                            </ul>
                        </div>
                    `;
                }

                html += '</div>';
                container.innerHTML = html;
                container.classList.add('open');

                // Gestion des clics sur les r√©sultats
                container.querySelectorAll('.global-search-item').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const type = btn.getAttribute('data-type');

                        if (type === 'event') {
                            const url = btn.getAttribute('data-lien');
                            if (url) {
                                // üëâ fiche √©v√©nement
                                window.open(url, '_blank');
                            }
                        } else if (type === 'person') {
                            const name = btn.getAttribute('data-person');
                            if (name) {
                                // üëâ fiche personnage (popup)
                                this.showPersonSheet(name);
                            }
                        }

                        container.innerHTML = '';
                        container.classList.remove('open');
                        input.blur();
                    });
                });
            }

            exportData() {
                const data = {
                    countries: this.cache.countries,
                    events: this.cache.events,
                    metadata: {
                        exportDate: new Date().toISOString(),
                        selectedYear: this.selectedYear,
                        selectedContinent: this.selectedContinent,
                        lastSync: this.cache.lastSync
                    }
                };
                
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `carte-historique-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
                this.showNotification('üìÅ Donn√©es export√©es', 'success');
            }

                    // ========================================
                    //      MODE COMPARAISON DE PAYS
                    // ========================================

                    // Lancer la comparaison depuis les selects
                    startComparison(countryA, countryB) {
                        this.compareMode = true;
                        this.countryA = countryA;
                        this.countryB = countryB;

                        // R√©cup√©rer les √©v√©nements pour chaque pays (sans filtre d'ann√©e)
                        const eventsA = this.cache.events.filter(ev =>
                            this.eventBelongsToCountry(ev, countryA)
                        ).sort((a, b) => new Date(a.date) - new Date(b.date));

                        const eventsB = this.cache.events.filter(ev =>
                            this.eventBelongsToCountry(ev, countryB)
                        ).sort((a, b) => new Date(a.date) - new Date(b.date));

                        if (eventsA.length === 0 && eventsB.length === 0) {
                            this.showNotification("Aucun √©v√©nement pour ces pays.", "warning");
                            return;
                        }

                        this.showDualTimeline(countryA, eventsA, countryB, eventsB);
                        this.highlightComparisonCountries(countryA, countryB);
                    }

                    // Sortir du mode comparaison
                    endComparison() {
                        this.compareMode = false;
                        this.countryA = null;
                        this.countryB = null;
                        this.compareEventsA = [];
                        this.compareEventsB = [];
                        this.compareDotsA = [];
                        this.compareDotsB = [];
                        this.selectedComparisonSide = null;
                        this.selectedComparisonIndex = null;

                        // On r√©initialise la timeline pour qu'elle puisse resservir en mode normal
                        const track = document.getElementById("timeline-track");
                        const content = document.getElementById("timeline-content");

                        if (track) track.innerHTML = "";
                        if (content) {
                            content.innerHTML = `<p>Cliquez sur un pays pour voir sa timeline...</p>`;
                        }

                        this.resetMapHighlights();
                    }

                    // Met en place la double frise + les colonnes d'√©v√©nements
                    showDualTimeline(countryA, eventsA, countryB, eventsB) {
                        const timeline = document.getElementById('timeline');
                        const timelineTrack = document.getElementById('timeline-track');
                        const timelineContent = document.getElementById('timeline-content');

                        if (!timeline || !timelineTrack || !timelineContent) return;

                        // S'assurer que la timeline est ouverte
                        timeline.classList.remove('collapsed');
                        const toggleBtn = document.getElementById('toggle-timeline');
                        if (toggleBtn) toggleBtn.textContent = '‚ñº';

                        // ========= 1) CONFIGURATION DES DEUX FRISES =============

                        timelineTrack.innerHTML = `
                            <div class="timeline-compare-wrapper">
                                <div class="timeline-compare-track-container">
                                    <div class="timeline-compare-track-label">üá¶ ${countryA}</div>
                                    <div class="timeline-compare-track" id="timeline-track-A"></div>
                                </div>
                                <div class="timeline-compare-track-container">
                                    <div class="timeline-compare-track-label">üáß ${countryB}</div>
                                    <div class="timeline-compare-track" id="timeline-track-B"></div>
                                </div>
                            </div>
                        `;

                        this.drawComparisonTimelines(eventsA, eventsB);

                        // ========= 2) CARTES D'√âV√âNEMENTS A / B C√îTE √Ä C√îTE =========

                        let html = `
                            <h3 style="color: var(--couleur-accent); margin-bottom: 16px;">
                                üîç Comparaison ‚Äì ${countryA} vs ${countryB}
                            </h3>
                            <div class="timeline-compare-grid">
                                <div class="timeline-compare-column">
                                    <h4>üá¶ ${countryA}</h4>
                        `;

                        if (eventsA.length === 0) {
                            html += `<p class="no-events">Aucun √©v√©nement pour ${countryA}.</p>`;
                        } else {
                            eventsA.forEach((ev, index) => {
                                const icon    = this.getCategoryIcon(ev.categorie);
                                const dateStr = this.formatDateHuman(ev.date);

                                html += `
                                    <div class="timeline-event compare-event" 
                                        data-side="A" 
                                        data-index="${index}">
                                        <div class="event-date">${icon} ${dateStr}</div>
                                        <div class="event-title">${ev.titre}</div>
                                        <div class="event-description">${ev.description || ""}</div>
                                    </div>
                                `;
                            });
                        }

                        html += `
                                </div>
                                <div class="timeline-compare-column">
                                    <h4>üáß ${countryB}</h4>
                        `;

                        if (eventsB.length === 0) {
                            html += `<p class="no-events">Aucun √©v√©nement pour ${countryB}.</p>`;
                        } else {
                            eventsB.forEach((ev, index) => {
                                const icon    = this.getCategoryIcon(ev.categorie);
                                const dateStr = this.formatDateHuman(ev.date);

                                html += `
                                    <div class="timeline-event compare-event" 
                                        data-side="B" 
                                        data-index="${index}">
                                        <div class="event-date">${icon} ${dateStr}</div>
                                        <div class="event-title">${ev.titre}</div>
                                        <div class="event-description">${ev.description || ""}</div>
                                    </div>
                                `;
                            });
                        }

                        html += `
                                </div>
                            </div>
                        `;

                        timelineContent.innerHTML = html;

                        // Cliquer sur une carte = s√©lectionner aussi les dots correspondants
                        document.querySelectorAll(".compare-event").forEach(card => {
                            card.addEventListener("click", () => {
                                const side = card.getAttribute("data-side");
                                const index = parseInt(card.getAttribute("data-index"), 10);
                                this.syncComparisonSelection(side, index);
                            });
                        });
                    }

                    // Dessine les deux frises (A et B) avec scroll synchronis√©
                    drawComparisonTimelines(eventsA, eventsB) {
                        const trackA = document.getElementById("timeline-track-A");
                        const trackB = document.getElementById("timeline-track-B");
                        if (!trackA || !trackB) return;

                        // M√©moriser les donn√©es
                        this.compareEventsA = eventsA;
                        this.compareEventsB = eventsB;
                        this.compareDotsA = [];
                        this.compareDotsB = [];
                        this.selectedComparisonSide = "A";
                        this.selectedComparisonIndex = 0;

                        // Calculer les bornes globales (A + B)
                        const allYears = [
                            ...eventsA.map(ev => parseInt(ev.date.split("-")[0], 10)),
                            ...eventsB.map(ev => parseInt(ev.date.split("-")[0], 10))
                        ].filter(y => !isNaN(y));

                        if (allYears.length === 0) return;

                        const minYear = Math.min(...allYears);
                        const maxYear = Math.max(...allYears);

                        const start = Math.floor(minYear / 100) * 100;
                        const end   = Math.ceil(maxYear / 100) * 100;
                        const visibleYears = end - start || 100;

                        const baseWidth = trackA.clientWidth || trackB.clientWidth || 800;
                        const targetWidth = baseWidth * 1.5;
                        let pxPerYear = targetWidth / visibleYears;

                        const MIN = 2;
                        const MAX = 15;
                        pxPerYear = Math.max(MIN, Math.min(MAX, pxPerYear));

                        const totalWidth = visibleYears * pxPerYear;

                        // Helper interne pour construire une frise
                        const buildTrack = (trackElement, events, side) => {
                            trackElement.innerHTML = "";
                            const inner = document.createElement("div");
                            inner.className = "timeline-compare-track-inner";
                            inner.style.width = totalWidth + "px";
                            trackElement.appendChild(inner);

                            // Axe
                            const axis = document.createElement("div");
                            axis.className = "timeline-compare-axis";
                            axis.style.width = totalWidth + "px";
                            inner.appendChild(axis);

                            // Rep√®res d'ann√©es (seulement sur la frise du haut pour all√©ger)
                            if (side === "A") {
                                for (let y = start; y <= end; y += 50) {
                                    const label = document.createElement("div");
                                    label.className = "timeline-compare-year";
                                    label.textContent = y;
                                    const x = (y - start) * pxPerYear;
                                    label.style.left = x + "px";
                                    inner.appendChild(label);
                                }
                            }

                            const dotsArray = (side === "A") ? this.compareDotsA : this.compareDotsB;

                            events.forEach((ev, index) => {
                                const year = parseInt(ev.date.split("-")[0], 10);
                                if (isNaN(year)) return;

                                const xPos = (year - start) * pxPerYear;
                                const dot = document.createElement("div");
                                dot.className = `timeline-compare-dot timeline-compare-dot-${side}`;
                                dot.style.left = xPos + "px";

                                const description = `${ev.date} ‚Äî ${ev.titre}`;

                                dot.title = description;

                                dot.addEventListener("click", () => {
                                    this.syncComparisonSelection(side, index);
                                });

                                dotsArray.push(dot);
                                inner.appendChild(dot);
                            });
                        };

                        buildTrack(trackA, eventsA, "A");
                        buildTrack(trackB, eventsB, "B");

                        // Scroll synchronis√©
                        let isSyncing = false;

                        const syncScroll = (source, target) => {
                            if (isSyncing) return;
                            isSyncing = true;
                            target.scrollLeft = source.scrollLeft;
                            isSyncing = false;
                        };

                        trackA.addEventListener("scroll", () => syncScroll(trackA, trackB));
                        trackB.addEventListener("scroll", () => syncScroll(trackB, trackA));

                        // S√©lection par d√©faut : premier √©v√©nement du pays A (ou B si A vide)
                        if (eventsA.length > 0) {
                            this.syncComparisonSelection("A", 0);
                        } else if (eventsB.length > 0) {
                            this.syncComparisonSelection("B", 0);
                        }
                    }

                    // Trouve l'index dans eventsOther le plus proche en ann√©e
                    findNearestIndexByYear(eventsOther, targetYear) {
                        if (!eventsOther || eventsOther.length === 0) return null;

                        let bestIndex = 0;
                        let bestDiff = Infinity;

                        eventsOther.forEach((ev, idx) => {
                            const year = parseInt(ev.date.split("-")[0], 10);
                            if (isNaN(year)) return;
                            const diff = Math.abs(year - targetYear);
                            if (diff < bestDiff) {
                                bestDiff = diff;
                                bestIndex = idx;
                            }
                        });

                        return bestIndex;
                    }

                    // S√©lection synchronis√©e : dots + cartes
                    syncComparisonSelection(side, index) {
                        this.selectedComparisonSide = side;
                        this.selectedComparisonIndex = index;

                        const eventsA = this.compareEventsA || [];
                        const eventsB = this.compareEventsB || [];
                        const dotsA = this.compareDotsA || [];
                        const dotsB = this.compareDotsB || [];

                        if (side === "A" && (!eventsA[index])) return;
                        if (side === "B" && (!eventsB[index])) return;

                        const primaryEvents = (side === "A") ? eventsA : eventsB;
                        const otherEvents   = (side === "A") ? eventsB : eventsA;
                        const primaryDots   = (side === "A") ? dotsA : dotsB;
                        const otherDots     = (side === "A") ? dotsB : dotsA;

                        const primaryTrack  = document.getElementById(side === "A" ? "timeline-track-A" : "timeline-track-B");
                        const otherTrack    = document.getElementById(side === "A" ? "timeline-track-B" : "timeline-track-A");

                        const ev = primaryEvents[index];
                        if (!ev) return;

                        const targetYear = parseInt(ev.date.split("-")[0], 10);

                        const otherIndex = this.findNearestIndexByYear(otherEvents, targetYear);

                        // Nettoyer les s√©lections pr√©c√©dentes
                        [...dotsA, ...dotsB].forEach(dot => dot.classList.remove("selected"));
                        document.querySelectorAll(".compare-event").forEach(card => {
                            card.classList.remove("highlight-compare");
                        });

                        // S√©lection c√¥t√© principal
                        const primaryDot = primaryDots[index];
                        if (primaryDot) {
                            primaryDot.classList.add("selected");
                            this.centerDotInTrack(primaryTrack, primaryDot);
                        }

                        // S√©lection c√¥t√© oppos√©
                        if (otherIndex !== null && otherDots[otherIndex]) {
                            const otherDot = otherDots[otherIndex];
                            otherDot.classList.add("selected");
                            this.centerDotInTrack(otherTrack, otherDot);
                        }

                        // Highlight des cartes
                        const selectorPrimary = `.compare-event[data-side="${side}"][data-index="${index}"]`;
                        const selectorOther   = `.compare-event[data-side="${side === "A" ? "B" : "A"}"][data-index="${otherIndex}"]`;

                        const cardPrimary = document.querySelector(selectorPrimary);
                        const cardOther   = document.querySelector(selectorOther);

                        if (cardPrimary) cardPrimary.classList.add("highlight-compare");
                        if (cardOther)   cardOther.classList.add("highlight-compare");
                    }

                    // Centre un dot dans son track
                    centerDotInTrack(track, dot) {
                        if (!track || !dot) return;
                        const x = dot.offsetLeft;
                        const targetScroll = Math.max(0, x - track.clientWidth / 2);
                        track.scrollTo({
                            left: targetScroll,
                            behavior: "smooth"
                        });
                    }

                    // Ajuster la vue de la carte pour voir les deux pays
                    highlightComparisonCountries(countryA, countryB) {
                        const countryObjA = this.cache.countries.find(
                            c => c.pays.toLowerCase() === countryA.toLowerCase()
                        );
                        const countryObjB = this.cache.countries.find(
                            c => c.pays.toLowerCase() === countryB.toLowerCase()
                        );

                        if (countryObjA && countryObjB) {
                            try {
                                this.map.fitBounds([
                                    countryObjA.coordonnees,
                                    countryObjB.coordonnees
                                ]);
                            } catch (e) {
                                console.warn("Impossible d'ajuster la vue pour la comparaison:", e);
                            }
                        }
                    }

                    // Plus tard tu pourras changer les ic√¥nes / opacit√©. Pour l'instant on ne fait que laisser la carte telle quelle.
                    resetMapHighlights() {
                        // Placeholder si tu veux plus tard r√©initialiser des styles sp√©ciaux de comparaison
                    }
                
            // ============================
            // POPUP ANNUAIRE ‚Äì GENERIQUE
            // ============================

            openDirectory(title, innerHtml) {
                if (!this.directoryOverlay || !this.directoryContentElem || !this.directoryTitleElem) return;
                this.directoryTitleElem.textContent = title;
                this.directoryContentElem.innerHTML = innerHtml;
                this.directoryOverlay.classList.add('open');
            }

            closeDirectory() {
                if (!this.directoryOverlay) return;
                this.directoryOverlay.classList.remove('open');
            }

            // Annuaire : tous les √©v√©nements (group√©s par pays)
            openEventsDirectory() {
                const events = [...(this.cache.events || [])];

                if (events.length === 0) {
                    this.openDirectory('tous les √©v√©nements par pays', '<p class="no-events">Aucun √©v√©nement √† afficher.</p>');
                    return;
                }

                // Regrouper par pays (en dupliquant l'√©v√©nement s'il concerne plusieurs pays)
                const groups = {};
                events.forEach(ev => {
                    let countries = this.eventCountries(ev); // g√®re d√©j√† string / liste
                    if (!countries || countries.length === 0) {
                        countries = ['(sans pays)'];
                    }

                    countries.forEach(rawName => {
                        const name = (rawName || '(sans pays)').toString().trim();
                        if (!groups[name]) groups[name] = [];
                        groups[name].push(ev);
                    });
                });

                // Trier les pays par ordre alphab√©tique
                const countryNames = Object.keys(groups).sort((a, b) =>
                    a.localeCompare(b, 'fr', { sensitivity: 'base' })
                );

                let html = '';

                countryNames.forEach(country => {
                    const list = groups[country];

                    // Trier les √©v√©nements de ce pays par titre
                    list.sort((a, b) => {
                        const ta = (a.titre || '').toString();
                        const tb = (b.titre || '').toString();
                        return ta.localeCompare(tb, 'fr', { sensitivity: 'base' });
                    });

                    html += `<section class="directory-section">
                                <div class="directory-letter">${country}</div>
                                <ul class="directory-list">`;

                    list.forEach(ev => {
                        const paysList = this.eventCountries(ev).join(', ');
                        const titre = ev.titre || '(sans titre)';
                        const date = ev.date || '';
                        const lien = ev.lien && ev.lien !== '#' ? ev.lien : null;

                        html += `
                            <li class="directory-item">
                                <div>
                                    ${
                                        lien
                                            ? `<a href="${lien}" target="_blank" class="directory-item-title directory-item-title-link">${titre}</a>`
                                            : `<span class="directory-item-title">${titre}</span>`
                                    }
                                    <div class="directory-item-meta">
                                        ${date ? `<span>${date}</span>` : ''}
                                        ${paysList ? `<span class="directory-chip">${paysList}</span>` : ''}
                                    </div>
                                </div>
                            </li>
                        `;
                    });

                    html += `   </ul>
                            </section>`;
                });

                this.openDirectory('tous les √©v√©nements par pays', html);
            }

            // Annuaire : toutes les notes Obsidian (inclut les notes hors carte)
            openNotesDirectory() {
                const notes = Array.isArray(this.cache.notes) ? [...this.cache.notes] : [];

                if (!notes.length) {
                    this.openDirectory('toutes les notes', '<p class="no-events">Aucune note √† afficher.</p>');
                    return;
                }

                notes.sort((a, b) => {
                    const ta = (a.titre || a.title || '').toString();
                    const tb = (b.titre || b.title || '').toString();
                    return ta.localeCompare(tb, 'fr', { sensitivity: 'base' });
                });

                let html = `<section class="directory-section"><ul class="directory-list">`;

                notes.forEach((note, index) => {
                    const titre = note.titre || note.title || '(sans titre)';
                    const date  = note.date ? this.formatDateHuman(note.date) : '';
                    const pays  = Array.isArray(note.pays) ? note.pays.join(', ') : (note.pays || '');

                    html += `
                        <li class="directory-item">
                            <button type="button"
                                    class="directory-item-title directory-note-link"
                                    data-note-index="${index}">
                                ${titre}
                            </button>
                            <div class="directory-item-meta">
                                ${date ? `<span>${date}</span>` : ''}
                                ${pays ? `<span class="directory-chip">${pays}</span>` : ''}
                            </div>
                        </li>
                    `;
                });

                html += `</ul></section>`;

                this.openDirectory('toutes les notes', html);

                if (this.directoryContentElem) {
                    this.directoryContentElem
                        .querySelectorAll('.directory-note-link')
                        .forEach(btn => {
                            btn.addEventListener('click', () => {
                                const indexStr = btn.getAttribute('data-note-index');
                                const idx = parseInt(indexStr, 10);
                                const note = notes[idx];
                                this.openNote(note);
                            });
                        });
                }
            }

            // Annuaire : tous les personnages (ordre alphab√©tique + lettres)
            openPersonsDirectory() {
                const persons = Object.values(this.personIndex || {});

                if (persons.length === 0) {
                    this.openDirectory('tous les personnages', '<p class="no-events">Aucun personnage r√©f√©renc√©.</p>');
                    return;
                }

                // Tri alphab√©tique global
                persons.sort((a, b) => {
                    const na = (a.nom || '').toString();
                    const nb = (b.nom || '').toString();
                    return na.localeCompare(nb, 'fr', { sensitivity: 'base' });
                });

                // Regroupement par lettre
                const groups = {};
                persons.forEach(p => {
                    const name = (p.nom || '').toString().trim();
                    const firstChar = name ? name[0].toUpperCase() : '?';
                    const letter = /[A-Z√Ä-√ñ√ò-√ù]/.test(firstChar) ? firstChar : '#';
                    if (!groups[letter]) groups[letter] = [];
                    groups[letter].push(p);
                });

                const letters = Object.keys(groups).sort((a, b) =>
                    a.localeCompare(b, 'fr', { sensitivity: 'base' })
                );

                let html = '';

                letters.forEach(letter => {
                    html += `<section class="directory-section">
                                <div class="directory-letter">${letter}</div>
                                <ul class="directory-list">`;

                    groups[letter].forEach(p => {
                        const paysSet = new Set();
                        (p.events || []).forEach(ev => {
                            this.eventCountries(ev).forEach(c => paysSet.add(c));
                        });
                        const paysList = Array.from(paysSet).join(', ');

                        html += `
                            <li class="directory-item">
                                <button type="button"
                                        class="directory-item-title directory-person-link"
                                        data-person="${p.nom}">
                                    ${p.nom}
                                </button>
                                <div class="directory-item-meta">
                                    <span>${(p.events || []).length} √©v√©nement(s)</span>
                                    ${paysList ? `<span class="directory-chip">${paysList}</span>` : ''}
                                </div>
                            </li>
                        `;
                    });

                    html += `   </ul>
                            </section>`;
                });

                this.openDirectory('tous les personnages', html);

                // Brancher les clics pour ouvrir la page du personnage
                if (this.directoryContentElem) {
                    this.directoryContentElem
                        .querySelectorAll('.directory-person-link')
                        .forEach(btn => {
                            btn.addEventListener('click', () => {
                                const name = btn.getAttribute('data-person');
                                this.closeDirectory();
                                this.showPersonPage(name);
                            });
                        });
                }
            }

            // Annuaire : tous les pays (ordre alphab√©tique + lettres)
            openCountriesDirectory() {
                const countries = this.cache.countries || [];

                if (!countries.length) {
                    this.openDirectory(
                        'tous les pays',
                        '<p class="no-events">Aucun pays r√©f√©renc√©.</p>'
                    );
                    return;
                }

                // Tri alphab√©tique global
                const sorted = [...countries].sort((a, b) => {
                    const na = (a.pays || '').toString();
                    const nb = (b.pays || '').toString();
                    return na.localeCompare(nb, 'fr', { sensitivity: 'base' });
                });

                // Regroupement par lettre
                const groups = {};
                sorted.forEach(c => {
                    const name = (c.pays || '(sans nom)').toString().trim();
                    const firstChar = name ? name[0].toUpperCase() : '?';
                    const letter = /[A-Z√Ä-√ñ√ò-√ù]/.test(firstChar) ? firstChar : '#';
                    if (!groups[letter]) groups[letter] = [];
                    groups[letter].push(c);
                });

                const letters = Object.keys(groups).sort((a, b) =>
                    a.localeCompare(b, 'fr', { sensitivity: 'base' })
                );

                let html = '';

                letters.forEach(letter => {
                    html += `<section class="directory-section">
                                <div class="directory-letter">${letter}</div>
                                <ul class="directory-list">`;

                    groups[letter].forEach(country => {
                        const name = (country.pays || '(sans nom)').toString();
                        const continent = country.continent || '';

                        // √©v√®nements li√©s √† ce pays
                        const events = this.getEventsForCountry(name) || [];
                        const years = events
                            .map(ev => parseInt((ev.date || '').split('-')[0], 10))
                            .filter(y => !isNaN(y));

                        const minY = years.length ? Math.min(...years) : null;
                        const maxY = years.length ? Math.max(...years) : null;

                        const periodLabel = (minY !== null && maxY !== null)
                            ? `${minY} ‚Äì ${maxY}`
                            : (minY !== null ? `${minY}` : 'p√©riode inconnue');

                        html += `
                            <li class="directory-item">
                                <button type="button"
                                        class="directory-item-title directory-country-link"
                                        data-country="${name}">
                                    ${name}
                                </button>
                                <div class="directory-item-meta">
                                    ${continent ? `<span class="directory-chip">${continent}</span>` : ''}
                                    <span>${events.length} √©v√©nement(s)</span>
                                    ${years.length ? `<span>${periodLabel}</span>` : ''}
                                </div>
                            </li>
                        `;
                    });

                    html += `   </ul>
                            </section>`;
                });

                this.openDirectory('tous les pays', html);

                // Clic sur un pays = ouvrir la fiche pays dans la sidebar
                if (this.directoryContentElem) {
                    this.directoryContentElem
                        .querySelectorAll('.directory-country-link')
                        .forEach(btn => {
                            btn.addEventListener('click', () => {
                                const countryName = btn.getAttribute('data-country');
                                this.closeDirectory();
                                this.showCountrySidebarSheet(countryName);
                                // Si un jour tu veux la version popup :
                                // this.showCountrySheet(countryName);
                            });
                        });
                }
            }

            // ============================
            // Gestion des vues (desktop / mobile)
            // ============================

            setMainView(view) {
                this.mainView = (view === 'timeline') ? 'timeline' : (view === 'notes' ? 'notes' : 'map');

                document.body.classList.remove('view-map', 'view-timeline', 'view-notes');
                if (this.mainView === 'timeline') {
                    document.body.classList.add('view-timeline');
                } else if (this.mainView === 'notes') {
                    document.body.classList.add('view-notes');
                } else {
                    document.body.classList.add('view-map');
                }

                // Met √† jour l'√©tat visuel des onglets desktop
                document.querySelectorAll('.main-tab').forEach(btn => {
                    const v = btn.dataset.mainView || 'map';
                    btn.classList.toggle('active', v === this.mainView);
                });

                // G√©rer l'√©tat "collapsed" de la timeline suivant la vue
                const timelineEl = document.getElementById('timeline');
                const toggleTimelineBtn = document.getElementById('toggle-timeline');
                if (timelineEl && toggleTimelineBtn) {
                    if (this.mainView === 'timeline') {
                        timelineEl.classList.remove('collapsed');
                        toggleTimelineBtn.textContent = '‚ñº';
                    } else {
                        timelineEl.classList.add('collapsed');
                        toggleTimelineBtn.textContent = '‚ñ≤';
                    }
                    timelineEl.style.display = (this.mainView === 'notes') ? 'none' : '';
                }

                // Vue notes : on met √† jour la grille d√©di√©e
                if (this.mainView === 'notes' && typeof this.renderNotesPanel === 'function') {
                    this.renderNotesPanel();
                }

                // Si on repasse en mode carte, on s'assure que le mobile mode est coh√©rent
                if (window.innerWidth <= 768) {
                    if (this.mainView === 'map' && this.mobileMode === 'timeline') {
                        this.setMobileMode('map');
                    } else if (this.mainView === 'notes' && this.mobileMode !== 'notes') {
                        this.setMobileMode('notes');
                    }
                }
            }

            setMobileMode(mode) {
                // mobile : 'map' | 'events' | 'timeline' | 'notes'
                this.mobileMode = (mode === 'events' || mode === 'timeline' || mode === 'notes') ? mode : 'map';

                document.body.classList.remove('mobile-mode-map', 'mobile-mode-events', 'mobile-mode-timeline', 'mobile-mode-notes');
                document.body.classList.add('mobile-mode-' + this.mobileMode);

                // Les onglets mobile
                document.querySelectorAll('.mobile-tab').forEach(btn => {
                    const v = btn.dataset.mobileView || 'map';
                    btn.classList.toggle('active', v === this.mobileMode);
                });

                // La vue principale associ√©e
                if (this.mobileMode === 'timeline') {
                    this.setMainView('timeline');
                } else if (this.mobileMode === 'notes') {
                    this.setMainView('notes');
                } else {
                    this.setMainView('map');
                }

                // Mode "√©v√©nements" : forcer la sidebar ouverte
                const sidebarEl = document.getElementById('sidebar');
                if (sidebarEl) {
                    if (this.mobileMode === 'events') {
                        sidebarEl.classList.remove('collapsed');
                    }
                }
            }
        }
        
        // ========================================
        // API PUBLIQUE POUR COMPATIBILIT√â
        // ========================================
        
        let historicalMap;
        
        function ajouterPays(nom, continent, latitude, longitude) {
            if (historicalMap) {
                const newCountry = {
                    pays: nom,
                    continent: continent,
                    coordonnees: [latitude, longitude]
                };
                historicalMap.cache.countries.push(newCountry);
                historicalMap.updateDisplay();
                historicalMap.showNotification(`‚úÖ Pays ajout√© : ${nom}`, 'success');
            }
        }
        
        function ajouterEvenement(pays, date, titre, description, categorie = 'general') {
            if (historicalMap) {
                const newEvent = {
                    pays: pays,
                    date: date,
                    titre: titre,
                    description: description,
                    categorie: categorie,
                    lien: '#'
                };
                historicalMap.cache.events.push(newEvent);
                historicalMap.updateDisplay();
                historicalMap.showNotification(`‚úÖ √âv√©nement ajout√© : ${titre}`, 'success');
            }
        }
        
        function synchroniserMaintenant() {
            if (historicalMap) {
                historicalMap.triggerSync();
            }
        }
        
        function activerSurveillance() {
            if (historicalMap && !historicalMap.watchMode) {
                historicalMap.toggleWatch();
            }
        }
        

        // ========================================
        // INITIALISATION
        // ========================================
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log("üöÄ Initialisation de la carte avec synchronisation Obsidian");
            
            historicalMap = new HistoricalMapWithSync();
            
            // Exposer pour le debugging
            window.historicalMap = historicalMap;
            window.ajouterPays = ajouterPays;
            window.ajouterEvenement = ajouterEvenement;
            window.synchroniserMaintenant = synchroniserMaintenant;
            window.activerSurveillance = activerSurveillance;
            
            console.log("‚úÖ Application avec sync Obsidian initialis√©e !");
            console.log("üí° Nouvelles commandes disponibles :");
            console.log("- synchroniserMaintenant()");
            console.log("- activerSurveillance()");
        });
        
        // Gestion des erreurs globales
        window.addEventListener('error', function(e) {
            console.error('Erreur JavaScript:', e.error);
            if (historicalMap) {
                historicalMap.showNotification('‚ùå Une erreur est survenue', 'error');
            }
        });
    </script>
</body>
</html>
