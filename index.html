<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte Historique - Synchronis√©e avec Obsidian</title>
    
    <!-- Leaflet CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    
    <style>
        /* Variables CSS optimis√©es */
        :root {
            --couleur-fond: #ffffff;
            --couleur-texte: #2d3748;
            --couleur-accent: #FFC5D3;
            --couleur-accent-hover: #FFC5D3;
            --couleur-bordure: #e2e8f0;
            --couleur-panneau: #f8fafc;
            --couleur-succes: #e0edc6;
            --couleur-attention: #f59e0b;
            --couleur-erreur: #ef4444;
            
            --espacement-xs: 4px;
            --espacement-sm: 8px;
            --espacement-md: 16px;
            --espacement-lg: 24px;
            --espacement-xl: 32px;
            
            --arrondi-sm: 6px;
            --arrondi-md: 8px;
            --arrondi-lg: 12px;
            
            --ombre-sm: 0 1px 2px rgba(0,0,0,0.05);
            --ombre-md: 0 4px 6px rgba(0,0,0,0.07);
            --ombre-lg: 0 10px 15px rgba(0,0,0,0.1);
            
            --transition-rapide: 0.15s ease;
            --transition-normale: 0.25s ease;
        }

        body.theme-sombre {
            --couleur-fond: #1a202c;
            --couleur-texte: #e2e8f0;
            --couleur-accent: #FFC5D3;
            --couleur-accent-hover: #cf9fab;
            --couleur-bordure: #4a5568;
            --couleur-panneau: #2d3748;
        }

        /* Reset et base */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--couleur-fond);
            color: var(--couleur-texte);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: background-color var(--transition-normale), color var(--transition-normale);
            overflow: hidden;
        }

        /* Header avec indicateur de synchronisation */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--espacement-md);
            background: var(--couleur-panneau);
            border-bottom: 1px solid var(--couleur-bordure);
            box-shadow: var(--ombre-sm);
            position: relative;
            z-index: 1000;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--espacement-sm);
        }

        .logo h1 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--couleur-accent);
        }

        .sync-indicator {
            display: flex;
            align-items: center;
            gap: var(--espacement-xs);
            padding: var(--espacement-xs) var(--espacement-sm);
            background: var(--couleur-succes);
            color: white;
            border-radius: var(--arrondi-sm);
            font-size: 0.8rem;
            font-weight: 500;
        }

        .sync-indicator.syncing {
            background: var(--couleur-attention);
        }

        .sync-indicator.error {
            background: var(--couleur-erreur);
        }

        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .header-controls {
            display: flex;
            gap: var(--espacement-sm);
            align-items: center;
        }

        .btn {
            background: var(--couleur-accent);
            color: white;
            border: none;
            padding: var(--espacement-sm) var(--espacement-md);
            border-radius: var(--arrondi-sm);
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all var(--transition-rapide);
            display: flex;
            align-items: center;
            gap: var(--espacement-xs);
        }

        .btn:hover {
            background: var(--couleur-accent-hover);
            transform: translateY(-1px);
            box-shadow: var(--ombre-md);
        }

        .btn-secondary {
            background: var(--couleur-panneau);
            color: var(--couleur-texte);
            border: 1px solid var(--couleur-bordure);
        }

        .btn-secondary:hover {
            background: var(--couleur-bordure);
        }

        /* Layout principal */
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            min-height: 0;   /* √©vite que la carte "pousse" en dehors du viewport */
        }

        .timeline {
            flex-shrink: 0;   /* la timeline garde sa hauteur, la carte s'adapte */
        }

        /* Sidebar avec section Obsidian */
        .sidebar {
            flex: 0 0 320px;              /* largeur de base dans le flex */
            max-width: 320px;
            background: var(--couleur-panneau);
            border-right: 1px solid var(--couleur-bordure);
            overflow-y: auto;
            transition: transform var(--transition-normale), 
                        flex-basis var(--transition-normale), 
                        max-width var(--transition-normale), 
                        padding var(--transition-normale), 
                        border var(--transition-normale);
            position: relative;
            z-index: 100;
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
            flex-basis: 0;       /* ne prend plus de place dans le flex */
            max-width: 0;
            padding: 0;
            border-right: none;
        }

        .sidebar-content {
            padding: var(--espacement-lg);
        }

        .control-section {
            margin-bottom: var(--espacement-xl);
        }

        .control-section h3 {
            margin-bottom: var(--espacement-md);
            color: var(--couleur-accent);
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--espacement-sm);
        }

        /* Section sp√©ciale Obsidian */
        .obsidian-section {
            background: linear-gradient(135deg, #FFC5D3, #cf92a1);
            color: white;
            padding: var(--espacement-lg);
            border-radius: var(--arrondi-lg);
            margin-bottom: var(--espacement-xl);
        }

        .obsidian-section h3 {
            color: white;
            margin-bottom: var(--espacement-md);
        }

        .obsidian-status {
            display: flex;
            align-items: center;
            gap: var(--espacement-sm);
            margin-bottom: var(--espacement-md);
        }

        .obsidian-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--espacement-sm);
        }

        .btn-obsidian {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .btn-obsidian:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        /* Contr√¥les de filtre */
        .range-control {
            background: var(--couleur-fond);
            border: 1px solid var(--couleur-bordure);
            border-radius: var(--arrondi-lg);
            padding: var(--espacement-lg);
        }

        .range-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--espacement-md);
            font-weight: 500;
        }

        .year-display {
            background: var(--couleur-accent);
            color: white;
            padding: var(--espacement-xs) var(--espacement-sm);
            border-radius: var(--arrondi-sm);
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }
        
        .year-input {
            background: var(--couleur-accent);
            color: white;
            border: none;
            padding: var(--espacement-xs) var(--espacement-sm);
            border-radius: var(--arrondi-sm);
            font-weight: 600;
            min-width: 80px;
            text-align: center;
            font-size: 0.9rem;
        }

        .year-input:focus {
            outline: 2px solid white;
            outline-offset: 2px;
        }
        
        .year-input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .range-slider {
            width: 100%;
            height: 6px;
            background: var(--couleur-bordure);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--couleur-accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--ombre-md);
            transition: all var(--transition-rapide);
        }

        .range-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* Frise chronologique horizontale */
        .timeline-horizontal {
            position: relative;
            margin-top: 16px;
            margin-bottom: 16px;
            height: 60px;
            border-top: 2px solid var(--couleur-accent);
        }
        
        /* Les points d'√©v√©nements sur la frise */
        .timeline-point {
            position: absolute;
            top: -5px;
            width: 10px;
            height: 10px;
            background: var(--couleur-accent);
            border-radius: 50%;
            transform: translateX(-50%);
        }
        
        /* Les rep√®res d'ann√©es sous la frise */
        .timeline-year {
            position: absolute;
            top: 12px;
            font-size: 0.75rem;
            transform: translateX(-50%);
            opacity: 0.7;
            white-space: nowrap;
        }
        
        /* Plage pour les √©v√©nements sur plusieurs ann√©es */
        .timeline-range {
            position: absolute;
            top: -3px;
            height: 6px;
            background: var(--couleur-accent);
            border-radius: 3px;
            opacity: 0.7;
        }
        
        /* Boutons de filtre d'affichage */
        .filter-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--espacement-sm);
        }
        
        .timeline-horizontal {
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 30px;
        }
        
        .timeline-track {
            position: relative;
            height: 150px;
            padding: 20px 0 20px 0;
            overflow-x: auto;
            overflow-y: visible;
            border-bottom: 1px solid var(--couleur-bordure);
            background: var(--couleur-panneau);
        }
        
        .timeline-track-inner {
            position: relative;
            height: 100%;
        }

        .timeline-nav {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 var(--espacement-lg);
        }

        /* La frise prend toute la place disponible entre les fl√®ches */
        .timeline-nav .timeline-track {
            flex: 1;
        }
        
        .timeline-arrow {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: 1px solid var(--couleur-bordure);
            background: var(--couleur-fond);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.15s;
        }

        .timeline-arrow:hover {
            background: var(--couleur-accent);
            color: white;
            border-color: var(--couleur-accent);
            transform: translateY(-1px);
        }

        .timeline-axis {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            height: 6px;                      /* √âPAISSEUR DE LA FRISE */
            background: linear-gradient(
                90deg,
                rgba(233, 164, 218, 0.8),
                rgba(196, 107, 181, 0.8)
            );
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
        }
        
        .timeline-year {
            position: absolute;
            top: calc(50% + 18px);
            transform: translateX(-50%);
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--couleur-texte);
            opacity: 0.8;
            text-shadow: 0 1px 2px rgba(255,255,255,0.7);
        }
        
        .timeline-dot {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 18px;  
            height: 18px; 
            background: white;
            border: 4px solid var(--couleur-accent);
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(59,130,246,0.4);  /* halo bleu */
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }

        .timeline-dot:hover {
            transform: translate(-50%, -50%) scale(1.45);
            box-shadow: 0 0 14px rgba(59,130,246,0.6);
        }

        .timeline-dot.selected {
            transform: translate(-50%, -50%) scale(1.8);
            box-shadow: 0 0 18px rgba(59,130,246,0.9);
        }
        
        .timeline-tooltip {
            position: absolute;
            top: 50%;                          
            transform: translate(-50%, -110%); 
            max-width: 220px;
            padding: 4px 8px;               
            background: white;
            color: var(--couleur-texte);
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            font-size: 0.75rem;          
            font-weight: 500;
            white-space: nowrap;              
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 20;
        }
        
        .timeline-tooltip.visible {
            opacity: 1;
        }

        .timeline-event.highlight {
            outline: 2px solid var(--couleur-accent);
            box-shadow: 0 0 0 2px rgba(59,130,246,0.3);
        }

        .btn-filter {
            padding: var(--espacement-sm) var(--espacement-md);
            background: var(--couleur-fond);
            border: 2px solid var(--couleur-bordure);
            border-radius: var(--arrondi-md);
            cursor: pointer;
            text-align: center;
            transition: all var(--transition-rapide);
            font-weight: 500;
            font-size: 0.9rem;
        }

        .btn-filter:hover {
            border-color: var(--couleur-accent);
            transform: translateY(-1px);
            box-shadow: var(--ombre-md);
        }

        .btn-filter.active {
            background: var(--couleur-accent);
            color: white;
            border-color: var(--couleur-accent);
        }

        /* Boutons continents */
        .continent-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--espacement-sm);
        }

        .btn-continent {
            padding: var(--espacement-md);
            background: var(--couleur-fond);
            border: 2px solid var(--couleur-bordure);
            border-radius: var(--arrondi-md);
            cursor: pointer;
            text-align: center;
            transition: all var(--transition-rapide);
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .btn-continent:hover {
            border-color: var(--couleur-accent);
            transform: translateY(-2px);
            box-shadow: var(--ombre-md);
        }

        .btn-continent.active {
            background: var(--couleur-accent);
            color: white;
            border-color: var(--couleur-accent);
        }


        /* Statistiques */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--espacement-md);
        }

        .stat-card {
            background: var(--couleur-fond);
            border: 1px solid var(--couleur-bordure);
            border-radius: var(--arrondi-lg);
            padding: var(--espacement-lg);
            text-align: center;
            transition: all var(--transition-rapide);
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--ombre-md);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--couleur-accent);
            line-height: 1;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--couleur-texte);
            margin-top: var(--espacement-xs);
        }

        /* Zone carte */
        .map-container {
            flex: 1;
            position: relative;
            background: var(--couleur-bordure);
            min-width: 0;  /* important en flex pour √©viter les d√©bordements */
            min-height: 0;
        }

        #carte {
            width: 100%;
            height: 100%;
            border: none;
        }

        .toggle-sidebar {
            position: absolute;
            top: var(--espacement-md);
            left: var(--espacement-md);
            z-index: 1001;
            background: var(--couleur-panneau);
            border: 1px solid var(--couleur-bordure);
            border-radius: var(--arrondi-sm);
            padding: var(--espacement-sm);
            cursor: pointer;
            box-shadow: var(--ombre-md);
            transition: all var(--transition-rapide);
        }

        .toggle-sidebar:hover {
            background: var(--couleur-accent);
            color: white;
        }

        .timeline-header-right {
            display: flex;
            align-items: center;
            gap: 10px; /* espace entre les onglets et le bouton ‚ñº */
        }

        .timeline-tabs {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* Timeline */
        .timeline {
            height: 400px;
            background: var(--couleur-panneau);
            border-top: 1px solid var(--couleur-bordure);
            display: flex;
            flex-direction: column;
            transition: height var(--transition-normale);
            position: relative;
        }

        .timeline.collapsed {
            height: 50px;
        }

        .timeline-header {
            padding: var(--espacement-md);
            border-bottom: 1px solid var(--couleur-bordure);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--couleur-panneau);
        }

        .timeline-content {
            max-height: 180px;
            overflow-y: auto;
            padding: var(--espacement-md);
        }

        .timeline-event {
            margin-bottom: var(--espacement-md);
            padding: var(--espacement-md);
            background: var(--couleur-fond);
            border-left: 4px solid var(--couleur-accent);
            border-radius: var(--arrondi-md);
            transition: all var(--transition-rapide);
        }

        .timeline-event:hover {
            transform: translateX(4px);
            box-shadow: var(--ombre-md);
        }

        .event-date {
            font-weight: 600;
            color: var(--couleur-accent);
            font-size: 0.9rem;
        }

        .event-title {
            font-weight: 600;
            margin: var(--espacement-xs) 0;
        }

        .event-description {
            font-size: 0.9rem;
            color: var(--couleur-texte);
            opacity: 0.8;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--couleur-succes);
            color: white;
            padding: var(--espacement-md) var(--espacement-lg);
            border-radius: var(--arrondi-md);
            box-shadow: var(--ombre-lg);
            z-index: 10000;
            font-weight: 500;
            transform: translateX(100%);
            transition: transform var(--transition-normale);
            max-width: 300px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: var(--couleur-erreur);
        }

        .notification.warning {
            background: var(--couleur-attention);
        }

        /* ========================================
        LISTE "TOUS LES √âV√âNEMENTS" ‚Äî STYLE PRO
        ======================================== */

            .events-list {
                margin-top: var(--espacement-sm);
                padding: var(--espacement-sm);
                background: var(--couleur-fond);
                border-radius: var(--arrondi-lg);
                border: 1px solid var(--couleur-bordure);
                box-shadow: var(--ombre-sm);
                max-height: 350px;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: var(--espacement-md);
            }

            /* --------- ITEM --------- */

            .event-item {
                background: var(--couleur-panneau);
                padding: var(--espacement-md);
                border-radius: var(--arrondi-md);
                border: 1px solid var(--couleur-bordure);
                box-shadow: var(--ombre-xs);
                cursor: pointer;
                transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
                position: relative;
            }

            .event-item:hover {
                transform: translateY(-3px);
                box-shadow: var(--ombre-lg);
            }

            /* --------- BARRE VERTICALE (effet timeline locale) --------- */

            .event-item::before {
                content: "";
                position: absolute;
                left: -10px;
                top: 0;
                bottom: 0;
                width: 3px;
                background: var(--couleur-accent);
                border-radius: 4px;
            }

            /* --------- DATE --------- */

            .event-date {
                font-size: 0.82rem;
                font-weight: 700;
                color: var(--couleur-accent);
                display: block;
                margin-bottom: 4px;
                opacity: 0.95;
            }

            /* --------- TITRE --------- */

            .event-title {
                font-size: 0.95rem;
                font-weight: 600;
                margin-bottom: 6px;
                line-height: 1.3;
            }

            /* --------- BADGE PAYS --------- */

            .event-country {
                display: inline-block;
                padding: 3px 8px;
                font-size: 0.75rem;
                border-radius: 12px;
                background: rgba(0,0,0,0.07);
                color: #333;
                font-weight: 600;
                opacity: 0.85;
                margin-top: 4px;
            }

            body.theme-sombre .event-country {
                background: rgba(255,255,255,0.08);
                color: #ddd;
            }

            /* --------- PAS D'√âV√âNEMENTS --------- */

            .events-list .no-events {
                font-size: 0.9rem;
                opacity: 0.7;
                text-align: center;
                padding: var(--espacement-sm);
            }
            
        /* Responsive */
        /* ========================================
            TIMELINE COMPARAISON DE PAYS
            ======================================== */

            .timeline-compare-wrapper {
                display: flex;
                gap: var(--espacement-lg);
                padding: var(--espacement-md) 0;
            }

            .timeline-compare-track-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: var(--espacement-sm);
            }

            .timeline-compare-track-label {
                font-size: 0.9rem;
                font-weight: 600;
                color: var(--couleur-texte);
                opacity: 0.9;
            }

            .timeline-compare-track {
                position: relative;
                height: 120px;
                overflow-x: auto;
                overflow-y: visible;
                border-bottom: 1px solid var(--couleur-bordure);
                background: var(--couleur-panneau);
                border-radius: var(--arrondi-md);
            }

            /* Conteneur interne qui s'√©tire en largeur selon la p√©riode */
            .timeline-compare-track-inner {
                position: relative;
                height: 100%;
            }

            /* Axe horizontal de la frise */
            .timeline-compare-axis {
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                height: 4px;
                background: linear-gradient(
                    90deg,
                    rgba(255, 197, 211, 0.9),
                    rgba(255, 156, 179, 0.9)
                );
                border-radius: 999px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            }

            /* Rep√®res d'ann√©es */
            .timeline-compare-year {
                position: absolute;
                top: calc(50% + 18px);
                transform: translateX(-50%);
                font-size: 0.7rem;
                font-weight: 500;
                opacity: 0.75;
            }

            /* Points d'√©v√©nements : base */
            .timeline-compare-dot {
                position: absolute;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 16px;
                height: 16px;
                background: var(--couleur-fond);
                border-radius: 50%;
                cursor: pointer;
                transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
            }

            /* Pays A : rose pastel */
            .timeline-compare-dot-A {
                border: 4px solid #FFC5D3;              /* rose pastel */
                box-shadow: 0 0 10px rgba(255, 197, 211, 0.6);
            }

            /* Pays B : bleu pastel */
            .timeline-compare-dot-B {
                border: 4px solid #C3E9FF;              /* bleu pastel */
                box-shadow: 0 0 10px rgba(195, 233, 255, 0.6);
            }

            .timeline-compare-dot:hover {
                transform: translate(-50%, -50%) scale(1.3);
            }

            /* S√©lection commune */
            .timeline-compare-dot.selected {
                transform: translate(-50%, -50%) scale(1.6);
                box-shadow: 0 0 16px rgba(0,0,0,0.25);
            }

            /* Grille pour les cartes d'√©v√©nements A / B */
            .timeline-compare-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: var(--espacement-md);
                margin-top: var(--espacement-md);
            }

            .timeline-compare-column h4 {
                margin-bottom: var(--espacement-sm);
                font-size: 0.95rem;
                color: var(--couleur-accent);
            }

            /* Highlight des cartes li√©es √† la s√©lection */
            .compare-event.highlight-compare {
                outline: 2px solid var(--couleur-accent);
                box-shadow: var(--ombre-md);
                background: rgba(255, 197, 211, 0.1);
            }

            /* Mobile : les colonnes passent l'une sous l'autre */
            @media (max-width: 768px) {
                .timeline-compare-wrapper {
                    flex-direction: column;
                }
                
                .timeline-compare-grid {
                    grid-template-columns: 1fr;
                }
            }

        
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                width: 100%;
                height: 100%;
                z-index: 2000;
            }
            
            .continent-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .timeline {
                height: 200px;
            }
        }

        /* Popup personnalis√©e pour Leaflet */
        .leaflet-popup-content-wrapper {
            border-radius: var(--arrondi-lg) !important;
            box-shadow: var(--ombre-lg) !important;
        }

        .leaflet-popup-content {
            margin: var(--espacement-md) !important;
            line-height: 1.6 !important;
        }

        /* Indicateur de chargement */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normale);
        }

        .loading-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--couleur-bordure);
            border-top: 4px solid var(--couleur-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Overlay de chargement -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

    <!-- Header avec indicateur de sync -->
    <header>
        <div class="logo">
            <h1>carte.</h1>
            <div class="sync-indicator" id="sync-indicator">
                <div class="sync-dot"></div>
                <span>Synchronis√©</span>
            </div>
        </div>
        <div class="header-controls">
            <button id="refresh-btn" class="btn btn-secondary" title="Actualiser les donn√©es">
                üîÑ
            </button>
            <button id="export-btn" class="btn btn-secondary" title="Exporter les donn√©es">
                üìÅ
            </button>
            <button id="theme-btn" class="btn" title="Changer le th√®me">
                üåì
            </button>
        </div>
    </header>

    <!-- Contenu principal -->
    <main>
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-content">
                

                

                <!-- Continents -->
                <section class="control-section">
                    <h3>continents.</h3>
                    <div class="continent-grid" role="group" aria-label="Filtres par continent">
                        <button class="btn-continent active" data-continent="tous">üåç Tous</button>
                        <button class="btn-continent" data-continent="europe">üåè Europe</button>
                        <button class="btn-continent" data-continent="asie">üåè Asie</button>
                        <button class="btn-continent" data-continent="afrique">üåç Afrique</button>
                        <button class="btn-continent" data-continent="amerique">üåé Am√©rique</button>
                        <button class="btn-continent" data-continent="oceanie">üåè Oc√©anie</button>
                    </div>
                </section>

                <!-- Filtre ann√©e -->
                <section class="control-section">
                    <h3>p√©riode.</h3>
                    <div class="range-control">
                        <div class="range-label">
                            <input type="number" 
                                id="input-annee" 
                                class="year-input"
                                min="-500" 
                                max="2024" 
                                value="2024"
                                placeholder="Tapez une ann√©e">
                        </div>
                        <input type="range" 
                            id="slider-annee" 
                            class="range-slider"
                            min="-2000" 
                            max="2024" 
                            value="2024"
                            aria-label="S√©lecteur d'ann√©e">
                    </div>
                </section>

                <!-- Filtre d'affichage des √©v√©nements -->
                <section class="control-section">
                    <h3>affichage.</h3>
                    <div class="filter-buttons">
                        <button class="btn-filter active" data-filter="year">ann√©e courante.</button>
                        <button class="btn-filter" data-filter="all">tout.</button>
                    </div>
                </section>

                <!-- Liste des √©v√©nements de l'ann√©e -->
                <section class="control-section">
                <h3>tous les √©v√©nements.</h3>
                <div class="events-list" id="events-list">
                    <p class="no-events">Aucun √©v√©nement.</p>
                </div>
                </section>
                
                <!-- Comparaison de pays -->
                <section class="control-section" id="compare-section">
                    <h3>comparer deux pays !</h3>
                    
                    <div class="compare-fields">
                        <label for="compare-country-a">1er pays</label>
                        <select id="compare-country-a">
                            <option value="">s√©lectionner un pays‚Ä¶</option>
                            <!-- options remplies en JS -->
                        </select>

                        <label for="compare-country-b">2e pays</label>
                        <select id="compare-country-b">
                            <option value="">s√©lectionner un pays‚Ä¶</option>
                            <!-- options remplies en JS -->
                        </select>

                        <div class="compare-buttons">
                            <button class="btn btn-secondary" id="compare-btn" type="button">
                                comparer.
                            </button>
                            <button class="btn btn-secondary" id="compare-reset-btn" type="button">
                                ‚úñ r√©initialiser.
                            </button>
                        </div>
                    </div>
                </section>

                <!-- Section Obsidian -->
                <section class="obsidian-section">
                    <h3>obsidian</h3>
                    <div class="obsidian-status">
                        <span>Derni√®re sync:</span>
                        <span id="last-sync">Jamais</span>
                    </div>
                    <div class="obsidian-actions">
                        <button class="btn btn-obsidian" id="sync-now" title="Synchroniser maintenant">
                            üîÑ
                        </button>
                        <button class="btn btn-obsidian" id="watch-toggle" title="Activer/d√©sactiver la surveillance">
                            üëÅÔ∏è
                        </button>
                    </div>
                </section>
            </div>
        </aside>

        <!-- Zone carte -->
        <section class="map-container">
            <button class="toggle-sidebar" id="toggle-sidebar" title="Afficher/Masquer le panneau">
                ‚ò∞
            </button>
            <div id="carte"></div>
        </section>
    </main>

    <!-- Timeline -->
    <footer class="timeline" id="timeline">
        <div class="timeline-header">
            <div class="timeline-header-left">
                <h2>timeline.</h2>
            </div>

            <div class="timeline-header-right">
                <!-- Onglets de mode -->
                <div class="timeline-tabs" id="timeline-tabs">
                    <button class="btn btn-secondary timeline-tab active" data-mode="country">
                        timeline du pays
                    </button>
                    <button class="btn btn-secondary timeline-tab" data-mode="world">
                        timeline mondiale
                    </button>
                </div>

                <button class="btn btn-secondary" id="toggle-timeline" title="R√©duire/√âtendre">
                    ‚ñº
                </button>
            </div>
        </div>

        <!-- TIMELINE PAYS (ton bloc existant, juste envelopp√©) -->
        <div class="timeline-country" id="timeline-country">
            <!-- Navigation + frise horizontale -->
            <div class="timeline-nav">
                <button class="timeline-arrow" id="timeline-prev" title="√âv√©nement pr√©c√©dent">‚óÄ</button>

                <div class="timeline-track" id="timeline-track">
                    <!-- rempli en JS -->
                </div>

                <button class="timeline-arrow" id="timeline-next" title="√âv√©nement suivant">‚ñ∂</button>
            </div>

            <!-- Liste des √©v√©nements du pays -->
            <div class="timeline-content" id="timeline-content">
                <p>Cliquez sur un pays pour voir sa timeline...</p>
            </div>
        </div>

        <!-- TIMELINE MONDIALE (nouveau bloc, cach√© au d√©but) -->
        <div class="timeline-global" id="timeline-global" style="display: none;">
            <div class="timeline-nav">
                <button class="timeline-arrow" id="timeline-global-prev" title="√âv√©nement pr√©c√©dent">‚óÄ</button>

                <div class="timeline-track" id="timeline-global-track">
                    <!-- sera rempli en JS avec tous les √©v√©nements -->
                </div>

                <button class="timeline-arrow" id="timeline-global-next" title="√âv√©nement suivant">‚ñ∂</button>
            </div>

            <div class="timeline-content" id="timeline-global-content">
                <p>Chronologie mondiale de tous les √©v√©nements...</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // ========================================
        // CLASSE PRINCIPALE AVEC SYNC OBSIDIAN
        // ========================================
        
        class HistoricalMapWithSync {
            constructor() {
                this.map = null;
                this.markers = null;
                this.selectedYear = 2024;
                this.selectedContinent = "tous";
                this.eventDisplayMode = "all"; // "year" ou "all"
                this.isDarkTheme = localStorage.getItem('theme-sombre') === 'true';
                this.isLoading = false;
                this.watchMode = false;
                this.timelineScaleMode = "auto"; // "auto" ou "fixed"
                this.timelineFixedPxPerYear = 4; // utilis√© seulement si mode "fixed"
                this.timelineDots = [];
                this.selectedTimelineIndex = null;
                this.currentTimelineEvents = [];
                this.compareMode = false;
                this.countryA = null;
                this.countryB = null;
                this.compareEventsA = [];
                this.compareEventsB = [];
                this.compareDotsA = [];
                this.compareDotsB = [];
                this.selectedComparisonSide = null;
                this.selectedComparisonIndex = null;
                this.timelineGlobalDots = [];
                this.currentGlobalTimelineEvents = [];
                this.selectedGlobalTimelineIndex = null;

                // Cache et donn√©es
                this.cache = {
                    countries: [],
                    events: [],
                    lastSync: null
                };
                
                // URLs des donn√©es (adaptez selon votre structure)
                this.dataUrls = {
                    events: 'data/evenements.json',
                    countries: 'data/pays.json'
                };
                
                this.init();

                // Zoom de la timeline par pays
                this.timelineZoom = 1;        // 1 = 1000 ans visibles par d√©faut
                this.timelineMinZoom = 0.5;   // d√©-zoom max (2000 ans visibles)
                this.timelineMaxZoom = 5;     // zoom max (200 ans visibles)

                // Zoom de la timeline mondiale
                this.timelineGlobalZoom = 1;        // 1 = ~1000 ans visibles
                this.timelineGlobalMinZoom = 0.5;   // d√©-zoom max (plus d'ann√©es)
                this.timelineGlobalMaxZoom = 5;     // zoom max (moins d'ann√©es)
            }
            
            async init() {
                console.log("üöÄ Initialisation avec synchronisation Obsidian");
                
                // Appliquer le th√®me
                if (this.isDarkTheme) {
                    document.body.classList.add('theme-sombre');
                }
                
                // Initialiser les composants
                this.initMap();
                this.initControls();
                this.initObsidianSync();
                
                // Charger les donn√©es
                await this.loadData();
                this.updateDisplay();
                
                console.log("‚úÖ Carte avec sync Obsidian initialis√©e");
            }
            
            initMap() {
                this.map = L.map('carte', {
                    center: [20, 0],
                    zoom: 2,
                    zoomControl: false
                });
                
                L.control.zoom({
                    position: 'bottomright'
                }).addTo(this.map);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 18
                }).addTo(this.map);
                
                this.markers = L.layerGroup().addTo(this.map);

                setTimeout(() => {
                    if (this.map) this.map.invalidateSize();
                }, 0);
            }
            
            initControls() {
                // Contr√¥les de base
                document.getElementById('theme-btn').addEventListener('click', () => {
                    this.toggleTheme();
                });

                // Boutons de filtre d'affichage
                document.querySelectorAll('.btn-filter').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.btn-filter').forEach(b => 
                            b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        this.eventDisplayMode = e.target.dataset.filter;
                        this.updateDisplay();
                    });
                });

                // Slider ann√©e avec champ de saisie synchronis√©
                const yearSlider = document.getElementById('slider-annee');
                const yearInput = document.getElementById('input-annee');

                let debounceTimer;

                // Fonction pour mettre √† jour l'ann√©e
                const updateYear = (newYear) => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        this.selectedYear = newYear;
                        this.updateDisplay();
                    }, 100);
                };

                // Synchronisation slider ‚Üí input
                yearSlider.addEventListener('input', (e) => {
                    const year = parseInt(e.target.value);
                    yearInput.value = year;
                    updateYear(year);
                });

                // Synchronisation input ‚Üí slider
                yearInput.addEventListener('input', (e) => {
                    const year = parseInt(e.target.value);
                    
                    // Validation de l'ann√©e
                    if (year >= -2000 && year <= 2024) {
                        yearSlider.value = year;
                        updateYear(year);
                    }
                });

                // Validation quand on appuie sur Entr√©e
                yearInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const year = parseInt(e.target.value);
                        
                        if (year >= -2000 && year <= 2024) {
                            yearSlider.value = year;
                            updateYear(year);
                            yearInput.blur(); // Enlever le focus
                        } else {
                            alert('Veuillez entrer une ann√©e entre -2000 et 2024');
                            yearInput.value = this.selectedYear; // Revenir √† l'ancienne valeur
                        }
                    }
                });
                
                // Boutons continents
                document.querySelectorAll('.btn-continent').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.btn-continent').forEach(b => 
                            b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        this.selectedContinent = e.target.dataset.continent;
                        this.updateDisplay();
                    });
                });
                
                //  SELECTEURS DE COMPARAISON
                const selectA = document.getElementById("compare-country-a");
                const selectB = document.getElementById("compare-country-b");

                // Fonction pour remplir les listes d√©roulantes de pays
                const fillCountrySelects = () => {
                    // vider au cas o√π
                    selectA.innerHTML = '<option value="">S√©lectionner un pays‚Ä¶</option>';
                    selectB.innerHTML = '<option value="">S√©lectionner un pays‚Ä¶</option>';

                    this.cache.countries.forEach(country => {
                        const optA = document.createElement("option");
                        const optB = document.createElement("option");

                        optA.value = country.pays;
                        optB.value = country.pays;

                        optA.textContent = country.pays;
                        optB.textContent = country.pays;

                        selectA.appendChild(optA);
                        selectB.appendChild(optB);
                    });
                };

                //      BOUTONS DE COMPARAISON
                document.getElementById("compare-btn").addEventListener("click", () => {
                    const countryA = selectA.value;
                    const countryB = selectB.value;

                    if (!countryA || !countryB || countryA === countryB) {
                        this.showNotification("S√©lectionnez deux pays diff√©rents.", "warning");
                        return;
                    }

                    // On stocke les choix
                    this.compareMode = true;
                    this.countryA = countryA;
                    this.countryB = countryB;

                    this.showNotification(`Comparaison activ√©e : ${countryA} vs ${countryB}`, "success");

                    // Lancer l'affichage comparatif (on fera la fonction apr√®s)
                    this.startComparison(countryA, countryB);
                });

                document.getElementById("compare-reset-btn").addEventListener("click", () => {
                    this.compareMode = false;
                    this.countryA = null;
                    this.countryB = null;

                    selectA.value = "";
                    selectB.value = "";

                    this.showNotification("Mode comparaison d√©sactiv√©.", "info");

                    // On remet l'affichage normal
                    this.endComparison();
                });

                // Remplir les selects lorsque les donn√©es sont charg√©es
                setTimeout(fillCountrySelects, 500); // petit d√©lai pour laisser loadData finir

                // Toggle sidebar et timeline
                const sidebarEl = document.getElementById('sidebar');
                const timelineEl = document.getElementById('timeline');
                const toggleSidebarBtn = document.getElementById('toggle-sidebar');
                const toggleTimelineBtn = document.getElementById('toggle-timeline');

                // Masquer / afficher la sidebar
                if (toggleSidebarBtn && sidebarEl) {
                    toggleSidebarBtn.addEventListener('click', () => {
                        sidebarEl.classList.toggle('collapsed');
                    });

                    // Quand la transition de la sidebar est termin√©e -> recalcul carte
                    sidebarEl.addEventListener('transitionend', (e) => {
                        if (!this.map) return;
                        // On ne r√©agit qu'aux changements de largeur / transform
                        if (e.propertyName === 'flex-basis' || e.propertyName === 'max-width' || e.propertyName === 'transform') {
                            this.map.invalidateSize();
                        }
                    });
                }

                // Abaisser / remonter la timeline
                if (toggleTimelineBtn && timelineEl) {
                    toggleTimelineBtn.addEventListener('click', () => {
                        timelineEl.classList.toggle('collapsed');
                        toggleTimelineBtn.textContent = timelineEl.classList.contains('collapsed') ? '‚ñ≤' : '‚ñº';
                    });

                    // Quand la hauteur de la timeline a fini de changer -> recalcul carte
                    timelineEl.addEventListener('transitionend', (e) => {
                        if (!this.map) return;
                        if (e.propertyName === 'height') {
                            this.map.invalidateSize();
                        }
                    });
                }

                // S√©curit√© : si la fen√™tre change de taille ‚Üí recalculer aussi
                window.addEventListener('resize', () => {
                    if (this.map) {
                        this.map.invalidateSize();
                    }
                });

                // Onglets timeline (pays / monde)
                const timelineTabs = document.querySelectorAll('.timeline-tab');
                const timelineCountry = document.getElementById('timeline-country');
                const timelineGlobal = document.getElementById('timeline-global');

                timelineTabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        timelineTabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');

                        const mode = tab.dataset.mode;

                        if (mode === 'country') {
                            // Afficher la timeline pays
                            if (timelineCountry) timelineCountry.style.display = 'block';
                            if (timelineGlobal) timelineGlobal.style.display = 'none';
                        } else if (mode === 'world') {
                            // Afficher la timeline mondiale
                            if (timelineCountry) timelineCountry.style.display = 'none';
                            if (timelineGlobal) timelineGlobal.style.display = 'block';
                            // (Re)construire la timeline mondiale avec les filtres actuels
                            this.showGlobalTimeline();
                        }

                        
                    });
                });
                
                

                // Fl√®ches de navigation dans la timeline
                const prevBtn = document.getElementById('timeline-prev');
                const nextBtn = document.getElementById('timeline-next');

                if (prevBtn && nextBtn) {
                    prevBtn.addEventListener('click', () => {
                        this.moveTimeline(-1);
                    });

                    nextBtn.addEventListener('click', () => {
                        this.moveTimeline(1);
                    });
                }
                
                // Export
                document.getElementById('export-btn').addEventListener('click', () => {
                    this.exportData();
                });
                
                // Actualiser
                document.getElementById('refresh-btn').addEventListener('click', () => {
                    this.loadData(true);
                });
            }
            
            initObsidianSync() {
                // Bouton sync manuel
                document.getElementById('sync-now').addEventListener('click', () => {
                    this.triggerSync();
                });
                
                // Toggle surveillance
                document.getElementById('watch-toggle').addEventListener('click', () => {
                    this.toggleWatch();
                });
                
                // Polling pour v√©rifier les mises √† jour
                this.startPolling();
                
                // Mettre √† jour l'affichage de la derni√®re sync
                this.updateLastSyncDisplay();
            }
            
            async loadData(forceReload = false) {
                if (this.isLoading && !forceReload) return;
                
                this.isLoading = true;
                this.showLoading(true);
                this.setSyncStatus('syncing', 'Chargement...');
                
                try {
                    console.log("üì¶ Chargement des donn√©es...");
                    
                    // Charger √©v√©nements et pays en parall√®le
                    const [eventsResponse, countriesResponse] = await Promise.all([
                        fetch(this.dataUrls.events + (forceReload ? '?t=' + Date.now() : '')),
                        fetch(this.dataUrls.countries + (forceReload ? '?t=' + Date.now() : ''))
                    ]);
                    
                    if (eventsResponse.ok && countriesResponse.ok) {
                        this.cache.events = await eventsResponse.json();
                        this.cache.countries = await countriesResponse.json();
                        this.cache.lastSync = new Date();
                        
                        console.log(`‚úÖ ${this.cache.events.length} √©v√©nements et ${this.cache.countries.length} pays charg√©s`);
                        this.setSyncStatus('success', 'Synchronis√©');
                        this.showNotification('üì¶ Donn√©es mises √† jour', 'success');
                    } else {
                        throw new Error('Erreur de chargement des donn√©es');
                    }
                    
                } catch (error) {
                    console.error("‚ùå Erreur de chargement:", error);
                    this.setSyncStatus('error', 'Erreur');
                    this.showNotification('‚ùå Erreur de chargement des donn√©es', 'error');
                    
                    // Donn√©es de fallback si aucune donn√©e n'est disponible
                    if (this.cache.events.length === 0) {
                        this.loadFallbackData();
                    }
                } finally {
                    this.isLoading = false;
                    this.showLoading(false);
                    this.updateLastSyncDisplay();
                }
            }
            
            loadFallbackData() {
                console.log("üîÑ Chargement des donn√©es de test");
                
                this.cache.countries = [
                    { pays: "France", continent: "europe", coordonnees: [46.603354, 1.888334] },
                    { pays: "Allemagne", continent: "europe", coordonnees: [51.165691, 10.451526] },
                    { pays: "√âtats-Unis", continent: "amerique", coordonnees: [37.09024, -95.712891] },
                    { pays: "Chine", continent: "asie", coordonnees: [35.86166, 104.195397] },
                    { pays: "√âgypte", continent: "afrique", coordonnees: [26.820553, 30.802498] }
                ];
                
                this.cache.events = [
                    {
                        pays: "France",
                        date: "1789-07-14",
                        titre: "Prise de la Bastille",
                        description: "D√©but de la R√©volution fran√ßaise",
                        categorie: "politique",
                        lien: "#"
                    },
                    {
                        pays: "√âtats-Unis",
                        date: "1776-07-04",
                        titre: "D√©claration d'ind√©pendance",
                        description: "Naissance des √âtats-Unis",
                        categorie: "politique",
                        lien: "#"
                    }
                ];
                
                this.showNotification('‚ö†Ô∏è Donn√©es de test charg√©es', 'warning');
            }
            
            updateDisplay() {
                if (this.isLoading) return;
                
                requestAnimationFrame(() => {
                    this.updateMarkers();
                    this.updateStats();
                    this.updateEventsList();
                });

                // Si l'onglet "Timeline mondiale" est actif, on la met aussi √† jour
                const worldTab = document.querySelector('.timeline-tab[data-mode="world"]');
                if (worldTab && worldTab.classList.contains('active')) {
                    this.showGlobalTimeline();
                }
            }
            
            updateMarkers() {
                this.markers.clearLayers();
                
                // Filtrer les pays
                let filteredCountries = this.cache.countries;
                if (this.selectedContinent !== "tous") {
                    filteredCountries = this.cache.countries.filter(
                        country => country.continent === this.selectedContinent
                    );
                }
                
                // Cr√©er les marqueurs
                filteredCountries.forEach(country => {
                    const events = this.getEventsForCountry(country.pays);
                    if (events.length > 0) {
                        this.createMarker(country, events);
                    }
                });
            }

            updateStats() {
                const nbPaysElement = document.getElementById('nb-pays');
                const nbEvenementsElement = document.getElementById('nb-evenements');

                if (!nbPaysElement || !nbEvenementsElement) return;

                let countriesWithEvents = 0;
                let totalEvents = 0;

                // On part des pays d√©j√† filtr√©s par continent
                let filteredCountries = this.cache.countries;
                if (this.selectedContinent !== "tous") {
                    filteredCountries = this.cache.countries.filter(
                        country => country.continent === this.selectedContinent
                    );
                }

                filteredCountries.forEach(country => {
                    // On regarde les √©v√©nements correspondant √† ce pays
                    const eventsForCountry = this.cache.events.filter(ev => {
                        if (ev.pays.toLowerCase() !== country.pays.toLowerCase()) {
                            return false;
                        }

                        // Mode "Tous les √©v√©nements" : on ne filtre pas par ann√©e
                        if (this.eventDisplayMode === "all") {
                            return true;
                        }

                        // Mode "Ann√©e courante" : uniquement les √©v√©nements visibles pour l'ann√©e s√©lectionn√©e
                        return this.isEventVisibleForYear(ev, this.selectedYear);
                    });

                    if (eventsForCountry.length > 0) {
                        countriesWithEvents++;
                        totalEvents += eventsForCountry.length;
                    }
                });

                // Utiliser l'animation si la m√©thode existe
                if (typeof this.animateNumber === 'function') {
                    this.animateNumber(nbPaysElement, countriesWithEvents);
                    this.animateNumber(nbEvenementsElement, totalEvents);
                } else {
                    nbPaysElement.textContent = countriesWithEvents;
                    nbEvenementsElement.textContent = totalEvents;
                }
            }

            isEventVisibleForYear(event, year) {
                const eventStartYear = parseInt(event.date.split('-')[0]);

                // 1) P√âRIODE D√âTERMIN√âE : visible entre d√©but et fin inclus
                if (event.date_fin) {
                    const eventEndYear = parseInt(event.date_fin.split('-')[0]);
                    return eventStartYear <= year && year <= eventEndYear;
                }

                // 2) PERP√âTUEL : visible √† partir de la date de d√©but
                if (event.perpetuel) {
                    return eventStartYear <= year;
                }

                // 3) PONCTUEL : visible UNIQUEMENT l'ann√©e o√π il a lieu
                return eventStartYear === year;
            }

            getEventsForCountry(countryName) {
                return this.cache.events.filter(event => {
                    // 1) On v√©rifie d'abord le pays
                    if (event.pays.toLowerCase() !== countryName.toLowerCase()) {
                        return false;
                    }

                    // 2) Mode "Tous les √©v√©nements" :
                    //    on ignore compl√®tement l'ann√©e s√©lectionn√©e.
                    if (this.eventDisplayMode === "all") {
                        return true;
                    }

                    // 3) Mode "Ann√©e courante" :
                    //    on utilise la logique commune de visibilit√©.
                    return this.isEventVisibleForYear(event, this.selectedYear);
                });
            }
            
            createMarker(country, events) {
                // 1Ô∏è‚É£ V√©rification de base : est-ce qu'on a bien un tableau de 2 √©l√©ments ?
                if (!country.coordonnees || 
                    !Array.isArray(country.coordonnees) || 
                    country.coordonnees.length !== 2) {
                    console.warn(`‚ùå Coordonn√©es invalides pour ${country.pays}:`, country.coordonnees);
                    return;
                }
                
                // 2Ô∏è‚É£ Conversion en nombres (m√™me si c'√©tait des strings)
                const lat = parseFloat(country.coordonnees[0]);
                const lng = parseFloat(country.coordonnees[1]);
                
                // 3Ô∏è‚É£ V√©rification que la conversion a fonctionn√©
                if (isNaN(lat) || isNaN(lng)) {
                    console.warn(`‚ùå Impossible de convertir en nombres pour ${country.pays}: [${country.coordonnees[0]}, ${country.coordonnees[1]}]`);
                    return;
                }
                
                // 4Ô∏è‚É£ V√©rification que les coordonn√©es sont r√©alistes
                if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    console.warn(`‚ùå Coordonn√©es hors limites pour ${country.pays}: [${lat}, ${lng}]`);
                    return;
                }

                const iconSize = Math.min(15 + events.length * 2, 30);
                const customIcon = L.divIcon({
                    html: `<div style="
                        width: ${iconSize}px;
                        height: ${iconSize}px;
                        background: var(--couleur-accent);
                        border: 3px solid white;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: ${Math.max(8, iconSize/3)}px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    ">${events.length}</div>`,
                    className: 'custom-marker',
                    iconSize: [iconSize, iconSize],
                    iconAnchor: [iconSize/2, iconSize/2]
                });
                
                let popupContent = `
                    <div style="min-width: 250px;">
                        <h3 style="margin: 0 0 12px 0; color: var(--couleur-accent);">${country.pays}</h3>
                        <p><strong>${events.length}</strong> √©v√©nement(s)</p>
                `;
                
                events.slice(0, 3).forEach(event => {
                    const categoryIcon = this.getCategoryIcon(event.categorie);
                    popupContent += `
                        <div style="margin: 8px 0; padding: 12px; background: #f0f0f0; border-radius: 6px;">
                            <div style="color: #3b82f6; font-weight: 600; margin-bottom: 4px;">
                                ${categoryIcon} ${event.date}
                            </div>
                            <div style="font-weight: 600;">
                                ${event.lien && event.lien !== '#' 
                                    ? `<a href="${event.lien}" target="_blank" style="color: #1e40af; text-decoration: underline;">${event.titre}</a>`
                                    : event.titre
                                }
                            </div>
            <div style="font-size: 0.9rem; opacity: 0.8;">${event.description}</div>
        </div>
                    `;
                });
                
                if (events.length > 3) {
                    popupContent += `<p><em>... et ${events.length - 3} autre(s)</em></p>`;
                }
                popupContent += '</div>';
                
                const marker = L.marker([lat, lng], { icon: customIcon })
                    .bindPopup(popupContent, { maxWidth: 350 })
                    .addTo(this.markers);
                
                marker.on('click', () => {
                    this.showTimeline(country.pays, events);
                });

                this.markers[country.pays] = marker;
            }
            
            getCategoryIcon(category) {
                const icons = {
                    'politique': 'üèõÔ∏è',
                    'science': 'üî¨',
                    'social': 'üë•',
                    'economie': 'üí∞',
                    'culture': 'üé®',
                    'guerre': '‚öîÔ∏è',
                    'default': 'üìÖ'
                };
                return icons[category] || icons.default;
            }
            
            showTimeline(countryName, eventsIgnor√©s) {
                const timelineContent = document.getElementById('timeline-content');
                const timeline = document.getElementById('timeline');

                if (!timelineContent || !timeline) return;

                timeline.classList.remove('collapsed');
                document.getElementById('toggle-timeline').textContent = '‚ñº';

                // ‚ö†Ô∏è On ignore compl√®tement le param√®tre "events"
                // et on r√©cup√®re TOUS les √©v√©nements de ce pays, toutes ann√©es confondues.
                const allEventsForCountry = this.cache.events
                    .filter(ev => ev.pays.toLowerCase() === countryName.toLowerCase())
                    .sort((a, b) => new Date(a.date) - new Date(b.date));

                let html = `
                    <h3 style="color: var(--couleur-accent); margin-bottom: 16px;">
                        üìú Timeline ‚Äì ${countryName}
                    </h3>
                `;

                if (!allEventsForCountry || allEventsForCountry.length === 0) {
                    html += `<p>Aucun √©v√©nement trouv√© pour ${countryName}.</p>`;
                    timelineContent.innerHTML = html;
                    this.drawTimeline([]); // vide la frise
                    return;
                }

                allEventsForCountry.forEach((event, index) => {
                    const categoryIcon = this.getCategoryIcon(event.categorie);
                    const eventId = `timeline-event-${index}`;

                    html += `
                        <div class="timeline-event" id="${eventId}" data-link="${event.lien}">
                            <div class="event-date">${categoryIcon} ${event.date}</div>
                            <div class="event-title">${event.titre}</div>
                            <div class="event-description">${event.description || ""}</div>
                        </div>
                    `;
                });

                timelineContent.innerHTML = html;

                // Clic sur une carte : ouvre la fiche
                document.querySelectorAll('.timeline-event').forEach(el => {
                    el.addEventListener('click', () => {
                        const link = el.getAttribute('data-link');
                        if (link && link !== '#') {
                            window.open(link, '_blank');
                        }
                    });
                });

                // Dessiner la frise sur TOUS les √©v√®nements du pays
                this.drawTimeline(allEventsForCountry);
            }

            drawTimeline(events) {
                const track = document.getElementById("timeline-track");
                if (!track) return;

                track.innerHTML = "";
                this.timelineDots = [];
                this.currentTimelineEvents = events || [];
                this.selectedTimelineIndex = null;

                if (!events || events.length === 0) return;

                const years = events
                    .map(ev => parseInt(ev.date.split("-")[0], 10))
                    .filter(y => !isNaN(y));

                if (years.length === 0) return;

                const maxYearEvents = Math.max(...years);

                // üïí Ann√©e "aujourd'hui"
                const currentYear = 2024;

                // On veut que l'axe aille au moins jusqu'√† aujourd'hui
                const finalMaxYear = Math.max(maxYearEvents, currentYear);

                // üß≠ D√©but de la timeline TOUJOURS √† -500
                const start = -500;
                const end   = Math.ceil(finalMaxYear / 100) * 100;
                const visibleYears = end - start || 100;

                // üéØ Objectif : ~1000 ans visibles √† l'√©cran pour zoom = 1
                const trackWidth = track.clientWidth || 800;
                const yearsPerScreen = 1000;
                let pxPerYear = (trackWidth / (yearsPerScreen * this.timelineZoom));

                const MIN = 0.5;
                const MAX = 30;
                pxPerYear = Math.max(MIN, Math.min(MAX, pxPerYear));

                const totalWidth = visibleYears * pxPerYear;

                // Conteneur interne
                const inner = document.createElement("div");
                inner.className = "timeline-track-inner";
                inner.style.width = totalWidth + "px";
                track.appendChild(inner);

                // Axe
                const axis = document.createElement("div");
                axis.className = "timeline-axis";
                axis.style.width = totalWidth + "px";
                inner.appendChild(axis);

                // Rep√®res d'ann√©es tous les 50 ans
                for (let y = start; y <= end; y += 50) {
                    const label = document.createElement("div");
                    label.className = "timeline-year";
                    label.textContent = y;
                    const x = (y - start) * pxPerYear;
                    label.style.left = x + "px";
                    inner.appendChild(label);
                }

                // Tooltip unique
                const tooltip = document.createElement("div");
                tooltip.className = "timeline-tooltip";
                inner.appendChild(tooltip);

                const dots = [];

                events.forEach((ev, index) => {
                    const year = parseInt(ev.date.split("-")[0], 10);
                    if (isNaN(year)) return;

                    // position horizontale bas√©e sur start = -500
                    const xPos = (year - start) * pxPerYear;
                    const dot = document.createElement("div");
                    dot.className = "timeline-dot";
                    dot.style.left = xPos + "px";

                    const description = `${ev.date} ‚Äî ${ev.titre}`;

                    dot.addEventListener("mouseenter", () => {
                        tooltip.textContent = description;
                        tooltip.style.left = xPos + "px";
                        tooltip.classList.add("visible");
                    });

                    dot.addEventListener("mouseleave", () => {
                        tooltip.classList.remove("visible");
                    });

                    dot.addEventListener("click", () => {
                        this.focusTimelineEvent(index);
                    });

                    dots.push(dot);
                    inner.appendChild(dot);
                });

                this.timelineDots = dots;

                // ‚úÖ s√©lectionner automatiquement le premier √©v√©nement
                if (dots.length > 0) {
                    this.focusTimelineEvent(0);
                }

                // üéöÔ∏è Zoom / d√©zoom √† la molette
                track.onwheel = (e) => {
                    e.preventDefault();

                    if (e.deltaY > 0) {
                        // d√©zoomer (voir plus d'ann√©es)
                        this.timelineZoom = Math.max(this.timelineMinZoom, this.timelineZoom / 1.6);
                    } else {
                        // zoomer (voir moins d'ann√©es)
                        this.timelineZoom = Math.min(this.timelineMaxZoom, this.timelineZoom * 1.6);
                    }

                    // on redessine la timeline avec le nouveau zoom
                    this.drawTimeline(this.currentTimelineEvents);

                    // on recentre sur l'√©v√®nement s√©lectionn√© si possible
                    if (this.selectedTimelineIndex !== null) {
                        this.focusTimelineEvent(this.selectedTimelineIndex);
                    }
                };
            }

            showGlobalTimeline() {
                const track = document.getElementById('timeline-global-track');
                const content = document.getElementById('timeline-global-content');
                if (!track || !content) return;

                // 1) S√©lection des √©v√©nements selon les filtres
                let events = [];

                if (this.eventDisplayMode === "all") {
                    // Tous les √©v√©nements (mode global)
                    events = [...this.cache.events];
                } else {
                    // Seulement ceux visibles pour l'ann√©e s√©lectionn√©e
                    events = this.cache.events.filter(ev =>
                        this.isEventVisibleForYear(ev, this.selectedYear)
                    );
                }

                // Filtre par continent si besoin
                if (this.selectedContinent !== "tous") {
                    const countriesInContinent = this.cache.countries
                        .filter(country => country.continent === this.selectedContinent)
                        .map(country => country.pays.toLowerCase());

                    events = events.filter(ev =>
                        countriesInContinent.includes(ev.pays.toLowerCase())
                    );
                }

                if (events.length === 0) {
                    track.innerHTML = "";
                    content.innerHTML = `<p>Aucun √©v√©nement √† afficher en chronologie mondiale.</p>`;
                    return;
                }

                // Trier par date
                events.sort((a, b) => new Date(a.date) - new Date(b.date));

                // 2) Dessiner la frise
                this.drawGlobalTimeline(events);

                // 3) Liste textuelle en dessous (simple)
                let html = `
                    <h3 style="color: var(--couleur-accent); margin-bottom: 16px;">
                        üåç Chronologie mondiale (${events.length} √©v√©nement(s))
                    </h3>
                `;

                events.forEach((ev, index) => {
                    const icon = this.getCategoryIcon(ev.categorie);
                    html += `
                        <div class="timeline-event" data-global-index="${index}">
                            <div class="event-date">${icon} ${ev.date} ‚Äì ${ev.pays}</div>
                            <div class="event-title">${ev.titre}</div>
                            <div class="event-description">${ev.description || ""}</div>
                        </div>
                    `;
                });

                content.innerHTML = html;

                // Cliquer sur une carte = focus sur le point dans la frise
                content.querySelectorAll(".timeline-event").forEach(card => {
                    card.addEventListener("click", () => {
                        const idx = parseInt(card.getAttribute("data-global-index"), 10);
                        this.focusGlobalTimelineEvent(idx);
                    });
                });
            }

            drawGlobalTimeline(events) {
                const track = document.getElementById("timeline-global-track");
                if (!track) return;

                track.innerHTML = "";
                this.timelineGlobalDots = [];
                this.currentGlobalTimelineEvents = events || [];
                this.selectedGlobalTimelineIndex = null;

                if (!events || events.length === 0) return;

                const years = events
                    .map(ev => parseInt(ev.date.split("-")[0], 10))
                    .filter(y => !isNaN(y));

                if (years.length === 0) return;

                const maxYearEvents = Math.max(...years);

                // üïí ann√©e "aujourd'hui"
                const currentYear = 2024;

                // l‚Äôaxe doit au moins aller jusqu‚Äô√† aujourd‚Äôhui
                const finalMaxYear = Math.max(maxYearEvents, currentYear);

                // üß≠ d√©but toujours √† -500 pour la timeline mondiale
                const start = -500;
                const end   = Math.ceil(finalMaxYear / 100) * 100;
                const visibleYears = end - start || 100;

                // üéØ ~1000 ans visibles √† l‚Äô√©cran pour zoom = 1
                const trackWidth = track.clientWidth || 800;
                const yearsPerScreen = 1000;
                let pxPerYear = trackWidth / (yearsPerScreen * this.timelineGlobalZoom);

                const MIN = 0.5;
                const MAX = 30;
                pxPerYear = Math.max(MIN, Math.min(MAX, pxPerYear));

                const totalWidth = visibleYears * pxPerYear;

                const inner = document.createElement("div");
                inner.className = "timeline-track-inner";
                inner.style.width = totalWidth + "px";
                track.appendChild(inner);

                // Axe
                const axis = document.createElement("div");
                axis.className = "timeline-axis";
                axis.style.width = totalWidth + "px";
                inner.appendChild(axis);

                // Rep√®res tous les 50 ans
                for (let y = start; y <= end; y += 50) {
                    const label = document.createElement("div");
                    label.className = "timeline-year";
                    label.textContent = y;
                    const x = (y - start) * pxPerYear;
                    label.style.left = x + "px";
                    inner.appendChild(label);
                }

                // Tooltip unique
                const tooltip = document.createElement("div");
                tooltip.className = "timeline-tooltip";
                inner.appendChild(tooltip);

                const dots = [];

                events.forEach((ev, index) => {
                    const year = parseInt(ev.date.split("-")[0], 10);
                    if (isNaN(year)) return;

                    const xPos = (year - start) * pxPerYear;
                    const dot = document.createElement("div");
                    dot.className = "timeline-dot"; // tu peux changer la classe si tu veux un look sp√©cial
                    dot.style.left = xPos + "px";

                    const description = `${ev.date} ‚Äì ${ev.pays} ‚Äì ${ev.titre}`;

                    dot.addEventListener("mouseenter", () => {
                        tooltip.textContent = description;
                        tooltip.style.left = xPos + "px";
                        tooltip.classList.add("visible");
                    });

                    dot.addEventListener("mouseleave", () => {
                        tooltip.classList.remove("visible");
                    });

                    dot.addEventListener("click", () => {
                        this.focusGlobalTimelineEvent(index);
                    });

                    dots.push(dot);
                    inner.appendChild(dot);
                });

                this.timelineGlobalDots = dots;
                this.currentGlobalTimelineEvents = events;

                if (dots.length > 0) {
                    this.focusGlobalTimelineEvent(0);
                }

                // Brancher les fl√®ches ‚óÄ ‚ñ∂ pour la timeline mondiale
                const prev = document.getElementById("timeline-global-prev");
                const next = document.getElementById("timeline-global-next");
                if (prev && next) {
                    prev.onclick = () => this.moveGlobalTimeline(-1);
                    next.onclick = () => this.moveGlobalTimeline(1);
                }

                // üéöÔ∏è Zoom / d√©zoom √† la molette
                track.onwheel = (e) => {
                    e.preventDefault();

                    if (e.deltaY > 0) {
                        // d√©zoomer (voir plus d‚Äôann√©es)
                        this.timelineGlobalZoom = Math.max(
                            this.timelineGlobalMinZoom,
                            this.timelineGlobalZoom / 1.2
                        );
                    } else {
                        // zoomer (voir moins d‚Äôann√©es)
                        this.timelineGlobalZoom = Math.min(
                            this.timelineGlobalMaxZoom,
                            this.timelineGlobalZoom * 1.2
                        );
                    }

                    // on redessine la timeline globale avec le nouveau zoom
                    this.drawGlobalTimeline(this.currentGlobalTimelineEvents);

                    // on recentre sur l‚Äô√©v√®nement s√©lectionn√© si possible
                    if (this.selectedGlobalTimelineIndex !== null) {
                        this.focusGlobalTimelineEvent(this.selectedGlobalTimelineIndex);
                    }
                };
            }

            focusGlobalTimelineEvent(index) {
                const track = document.getElementById('timeline-global-track');
                if (!track || !this.timelineGlobalDots || this.timelineGlobalDots.length === 0) return;

                if (index < 0 || index >= this.timelineGlobalDots.length) return;

                this.selectedGlobalTimelineIndex = index;

                this.timelineGlobalDots.forEach(dot => dot.classList.remove('selected'));

                const dot = this.timelineGlobalDots[index];
                if (!dot) return;

                dot.classList.add('selected');

                const trackWidth = track.clientWidth || 0;
                const xPos = dot.offsetLeft;
                const targetScrollLeft = xPos - trackWidth / 2;
                track.scrollTo({
                    left: Math.max(0, targetScrollLeft),
                    behavior: 'smooth'
                });

                // Faire d√©filer la liste texte correspondante
                const content = document.getElementById('timeline-global-content');
                if (content) {
                    const card = content.querySelector(`.timeline-event[data-global-index="${index}"]`);
                    if (card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        card.classList.add('highlight');
                        setTimeout(() => card.classList.remove('highlight'), 1500);
                    }
                }
            }

            moveGlobalTimeline(delta) {
                if (!this.timelineGlobalDots || this.timelineGlobalDots.length === 0) return;

                let index = (this.selectedGlobalTimelineIndex !== null)
                    ? this.selectedGlobalTimelineIndex
                    : 0;

                index += delta;

                if (index < 0) index = 0;
                if (index >= this.timelineGlobalDots.length) {
                    index = this.timelineGlobalDots.length - 1;
                }

                this.focusGlobalTimelineEvent(index);
            }

            focusTimelineEvent(index) {
                const track = document.getElementById('timeline-track');
                if (!track || !this.timelineDots || this.timelineDots.length === 0) return;

                if (index < 0 || index >= this.timelineDots.length) return;

                // Mettre √† jour l'index s√©lectionn√©
                this.selectedTimelineIndex = index;

                // Nettoyer la s√©lection pr√©c√©dente
                this.timelineDots.forEach(dot => dot.classList.remove('selected'));

                const dot = this.timelineDots[index];
                if (!dot) return;

                // Appliquer l'√©tat s√©lectionn√©
                dot.classList.add('selected');

                // Centrer le point dans la frise
                const trackWidth = track.clientWidth || 0;
                const xPos = dot.offsetLeft;
                const targetScrollLeft = xPos - trackWidth / 2;
                track.scrollTo({
                    left: Math.max(0, targetScrollLeft),
                    behavior: 'smooth'
                });

                // Faire d√©filer la liste vers l'√©v√®nement correspondant
                const target = document.getElementById(`timeline-event-${index}`);
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    target.classList.add('highlight');
                    setTimeout(() => target.classList.remove('highlight'), 1500);
                }
            }

            moveTimeline(delta) {
                if (!this.timelineDots || this.timelineDots.length === 0) return;

                let index = (this.selectedTimelineIndex !== null)
                    ? this.selectedTimelineIndex
                    : 0;

                index += delta;

                // On bloque au d√©but / √† la fin
                if (index < 0) index = 0;
                if (index >= this.timelineDots.length) index = this.timelineDots.length - 1;

                this.focusTimelineEvent(index);
            }  

            updateEventsList() {
                const eventsList = document.getElementById('events-list');
                let currentYearEvents = [];

                if (this.eventDisplayMode === "all") {
                    // Mode "Tous les √©v√©nements" : afficher TOUS les √©v√©nements de TOUTES les ann√©es
                    currentYearEvents = [...this.cache.events];
                    
                    // Filtrer par continent uniquement (pas d'ann√©e)
                    if (this.selectedContinent !== "tous") {
                        const countriesInContinent = this.cache.countries
                            .filter(country => country.continent === this.selectedContinent)
                            .map(country => country.pays.toLowerCase());
                        
                        currentYearEvents = currentYearEvents.filter(event => 
                            countriesInContinent.includes(event.pays.toLowerCase())
                        );
                    }
                } else {
                    // Mode "Ann√©e courante" : filtrer les √©v√©nements pour l'ann√©e s√©lectionn√©e
                    currentYearEvents = this.cache.events.filter(event => 
                        this.isEventVisibleForYear(event, this.selectedYear)
                    );

                    // Filtrer par continent si n√©cessaire
                    if (this.selectedContinent !== "tous") {
                        const countriesInContinent = this.cache.countries
                            .filter(country => country.continent === this.selectedContinent)
                            .map(country => country.pays.toLowerCase());
                        
                        currentYearEvents = currentYearEvents.filter(event => 
                            countriesInContinent.includes(event.pays.toLowerCase())
                        );
                    }
                }
                
                if (currentYearEvents.length === 0) {
                    const message = this.eventDisplayMode === "all" 
                        ? 'Aucun √©v√©nement trouv√©' 
                        : 'Aucun √©v√©nement pour cette ann√©e';
                    eventsList.innerHTML = `<p class="no-events">${message}</p>`;
                    return;
                }

                // Trier par date
                currentYearEvents.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                let html = '';
                currentYearEvents.forEach(event => {
                    const categoryIcon = this.getCategoryIcon(event.categorie);
                    
                    html += `
                        <div class="event-item" onclick="historicalMap.focusOnCountry('${event.pays}')">
                            <div class="event-date">${categoryIcon} ${event.date}</div>
                            <div class="event-title">${event.titre}</div>
                            <div class="event-country">${event.pays}</div>
                        </div>
                    `;
                });
                
                eventsList.innerHTML = html;
            }

            focusOnCountry(countryName) {
                // Trouver le pays
                const country = this.cache.countries.find(c => 
                    c.pays.toLowerCase() === countryName.toLowerCase()
                );
                
                if (country && country.coordonnees) {
                    // Centrer la carte sur le pays
                    this.map.setView(country.coordonnees, 6);
                    
                    // Montrer les √©v√©nements du pays dans la timeline
                    const events = this.cache.events
                        .filter(ev => ev.pays.toLowerCase() === country.pays.toLowerCase())
                        .sort((a, b) => new Date(a.date) - new Date(b.date));
                    this.showTimeline(country.pays, events);
                    
                    // Fermer la sidebar sur mobile
                    if (window.innerWidth <= 768) {
                        document.getElementById('sidebar').classList.add('collapsed');
                    }
                }
            }
                        
                        animateNumber(element, targetValue) {
                            const currentValue = parseInt(element.textContent) || 0;
                            const increment = Math.ceil((targetValue - currentValue) / 10);
                            
                            if (currentValue !== targetValue) {
                                element.textContent = Math.max(0, currentValue + increment);
                                setTimeout(() => this.animateNumber(element, targetValue), 50);
                            } else {
                                element.textContent = targetValue;
                            }
                        }
            
            // ========================================
            // FONCTIONS SYNCHRONISATION OBSIDIAN
            // ========================================
            
            async triggerSync() {
                this.setSyncStatus('syncing', 'Synchronisation...');
                this.showNotification('üîÑ Synchronisation en cours...', 'info');
                
                try {
                    // Simplement recharger les donn√©es depuis les fichiers JSON locaux
                    await this.loadData(true);
                    this.setSyncStatus('success', 'Synchronis√©');
                    this.showNotification('‚úÖ Donn√©es recharg√©es', 'success');
        
                    // Mettre √† jour l'affichage de la derni√®re sync
                    this.cache.lastSync = new Date();
                    this.updateLastSyncDisplay();

                } catch (error) {
                    console.error("‚ùå Erreur de synchronisation:", error);
                    this.setSyncStatus('error', 'Erreur sync');
                    this.showNotification('‚ùå Erreur de synchronisation', 'error');
                }
            }
            
            toggleWatch() {
                this.watchMode = !this.watchMode;
                const button = document.getElementById('watch-toggle');
                
                if (this.watchMode) {
                    button.textContent = 'üëÅÔ∏è Stop';
                    button.style.background = 'rgba(239, 68, 68, 0.2)';
                    this.startPolling(5000); // Poll plus fr√©quent
                    this.showNotification('üëÅÔ∏è Surveillance activ√©e', 'success');
                } else {
                    button.textContent = 'üëÅÔ∏è Watch';
                    button.style.background = 'rgba(255, 255, 255, 0.2)';
                    this.startPolling(30000); // Poll normal
                    this.showNotification('‚èπÔ∏è Surveillance d√©sactiv√©e', 'info');
                }
            }
            
            startPolling(interval = 30000) {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                }
                
                this.pollInterval = setInterval(() => {
                    this.checkForUpdates();
                }, interval);
            }
            
            async checkForUpdates() {
                // Mode local - pas de v√©rification serveur
                console.debug("Mode local actif - pas de v√©rification serveur");
                return;
            }
            
            setSyncStatus(status, text) {
                const indicator = document.getElementById('sync-indicator');
                const statusText = indicator.querySelector('span');
                
                indicator.className = `sync-indicator ${status}`;
                statusText.textContent = text;
            }
            
            updateLastSyncDisplay() {
                const lastSyncElement = document.getElementById('last-sync');
                if (this.cache.lastSync) {
                    const time = this.cache.lastSync.toLocaleTimeString('fr-FR', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    lastSyncElement.textContent = time;
                } else {
                    lastSyncElement.textContent = 'Jamais';
                }
            }
            
            // ========================================
            // FONCTIONS UTILITAIRES
            // ========================================
            
            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                
                if (this.isDarkTheme) {
                    document.body.classList.add('theme-sombre');
                } else {
                    document.body.classList.remove('theme-sombre');
                }
                
                localStorage.setItem('theme-sombre', this.isDarkTheme);
            }
            
            showLoading(show) {
                const overlay = document.getElementById('loading-overlay');
                if (show) {
                    overlay.classList.add('show');
                } else {
                    overlay.classList.remove('show');
                }
            }
            
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => notification.classList.add('show'), 10);
                
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => document.body.removeChild(notification), 300);
                }, 3000);
            }
            
            exportData() {
                const data = {
                    countries: this.cache.countries,
                    events: this.cache.events,
                    metadata: {
                        exportDate: new Date().toISOString(),
                        selectedYear: this.selectedYear,
                        selectedContinent: this.selectedContinent,
                        lastSync: this.cache.lastSync
                    }
                };
                
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `carte-historique-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
                this.showNotification('üìÅ Donn√©es export√©es', 'success');
            }

                    // ========================================
                    //      MODE COMPARAISON DE PAYS
                    // ========================================

                    // Lancer la comparaison depuis les selects
                    startComparison(countryA, countryB) {
                        this.compareMode = true;
                        this.countryA = countryA;
                        this.countryB = countryB;

                        // R√©cup√©rer les √©v√©nements pour chaque pays (sans filtre d'ann√©e)
                        const eventsA = this.cache.events.filter(ev =>
                            ev.pays.toLowerCase() === countryA.toLowerCase()
                        ).sort((a, b) => new Date(a.date) - new Date(b.date));

                        const eventsB = this.cache.events.filter(ev =>
                            ev.pays.toLowerCase() === countryB.toLowerCase()
                        ).sort((a, b) => new Date(a.date) - new Date(b.date));

                        if (eventsA.length === 0 && eventsB.length === 0) {
                            this.showNotification("Aucun √©v√©nement pour ces pays.", "warning");
                            return;
                        }

                        this.showDualTimeline(countryA, eventsA, countryB, eventsB);
                        this.highlightComparisonCountries(countryA, countryB);
                    }

                    // Sortir du mode comparaison
                    endComparison() {
                        this.compareMode = false;
                        this.countryA = null;
                        this.countryB = null;
                        this.compareEventsA = [];
                        this.compareEventsB = [];
                        this.compareDotsA = [];
                        this.compareDotsB = [];
                        this.selectedComparisonSide = null;
                        this.selectedComparisonIndex = null;

                        // On r√©initialise la timeline pour qu'elle puisse resservir en mode normal
                        const track = document.getElementById("timeline-track");
                        const content = document.getElementById("timeline-content");

                        if (track) track.innerHTML = "";
                        if (content) {
                            content.innerHTML = `<p>Cliquez sur un pays pour voir sa timeline...</p>`;
                        }

                        this.resetMapHighlights();
                    }

                    // Met en place la double frise + les colonnes d'√©v√©nements
                    showDualTimeline(countryA, eventsA, countryB, eventsB) {
                        const timeline = document.getElementById('timeline');
                        const timelineTrack = document.getElementById('timeline-track');
                        const timelineContent = document.getElementById('timeline-content');

                        if (!timeline || !timelineTrack || !timelineContent) return;

                        // S'assurer que la timeline est ouverte
                        timeline.classList.remove('collapsed');
                        const toggleBtn = document.getElementById('toggle-timeline');
                        if (toggleBtn) toggleBtn.textContent = '‚ñº';

                        // ========= 1) CONFIGURATION DES DEUX FRISES =============

                        timelineTrack.innerHTML = `
                            <div class="timeline-compare-wrapper">
                                <div class="timeline-compare-track-container">
                                    <div class="timeline-compare-track-label">üá¶ ${countryA}</div>
                                    <div class="timeline-compare-track" id="timeline-track-A"></div>
                                </div>
                                <div class="timeline-compare-track-container">
                                    <div class="timeline-compare-track-label">üáß ${countryB}</div>
                                    <div class="timeline-compare-track" id="timeline-track-B"></div>
                                </div>
                            </div>
                        `;

                        this.drawComparisonTimelines(eventsA, eventsB);

                        // ========= 2) CARTES D'√âV√âNEMENTS A / B C√îTE √Ä C√îTE =========

                        let html = `
                            <h3 style="color: var(--couleur-accent); margin-bottom: 16px;">
                                üîç Comparaison ‚Äì ${countryA} vs ${countryB}
                            </h3>
                            <div class="timeline-compare-grid">
                                <div class="timeline-compare-column">
                                    <h4>üá¶ ${countryA}</h4>
                        `;

                        if (eventsA.length === 0) {
                            html += `<p class="no-events">Aucun √©v√©nement pour ${countryA}.</p>`;
                        } else {
                            eventsA.forEach((ev, index) => {
                                const icon = this.getCategoryIcon(ev.categorie);
                                html += `
                                    <div class="timeline-event compare-event" 
                                        data-side="A" 
                                        data-index="${index}">
                                        <div class="event-date">${icon} ${ev.date}</div>
                                        <div class="event-title">${ev.titre}</div>
                                        <div class="event-description">${ev.description || ""}</div>
                                    </div>
                                `;
                            });
                        }

                        html += `
                                </div>
                                <div class="timeline-compare-column">
                                    <h4>üáß ${countryB}</h4>
                        `;

                        if (eventsB.length === 0) {
                            html += `<p class="no-events">Aucun √©v√©nement pour ${countryB}.</p>`;
                        } else {
                            eventsB.forEach((ev, index) => {
                                const icon = this.getCategoryIcon(ev.categorie);
                                html += `
                                    <div class="timeline-event compare-event" 
                                        data-side="B" 
                                        data-index="${index}">
                                        <div class="event-date">${icon} ${ev.date}</div>
                                        <div class="event-title">${ev.titre}</div>
                                        <div class="event-description">${ev.description || ""}</div>
                                    </div>
                                `;
                            });
                        }

                        html += `
                                </div>
                            </div>
                        `;

                        timelineContent.innerHTML = html;

                        // Cliquer sur une carte = s√©lectionner aussi les dots correspondants
                        document.querySelectorAll(".compare-event").forEach(card => {
                            card.addEventListener("click", () => {
                                const side = card.getAttribute("data-side");
                                const index = parseInt(card.getAttribute("data-index"), 10);
                                this.syncComparisonSelection(side, index);
                            });
                        });
                    }

                    // Dessine les deux frises (A et B) avec scroll synchronis√©
                    drawComparisonTimelines(eventsA, eventsB) {
                        const trackA = document.getElementById("timeline-track-A");
                        const trackB = document.getElementById("timeline-track-B");
                        if (!trackA || !trackB) return;

                        // M√©moriser les donn√©es
                        this.compareEventsA = eventsA;
                        this.compareEventsB = eventsB;
                        this.compareDotsA = [];
                        this.compareDotsB = [];
                        this.selectedComparisonSide = "A";
                        this.selectedComparisonIndex = 0;

                        // Calculer les bornes globales (A + B)
                        const allYears = [
                            ...eventsA.map(ev => parseInt(ev.date.split("-")[0], 10)),
                            ...eventsB.map(ev => parseInt(ev.date.split("-")[0], 10))
                        ].filter(y => !isNaN(y));

                        if (allYears.length === 0) return;

                        const minYear = Math.min(...allYears);
                        const maxYear = Math.max(...allYears);

                        const start = Math.floor(minYear / 100) * 100;
                        const end   = Math.ceil(maxYear / 100) * 100;
                        const visibleYears = end - start || 100;

                        const baseWidth = trackA.clientWidth || trackB.clientWidth || 800;
                        const targetWidth = baseWidth * 1.5;
                        let pxPerYear = targetWidth / visibleYears;

                        const MIN = 2;
                        const MAX = 15;
                        pxPerYear = Math.max(MIN, Math.min(MAX, pxPerYear));

                        const totalWidth = visibleYears * pxPerYear;

                        // Helper interne pour construire une frise
                        const buildTrack = (trackElement, events, side) => {
                            trackElement.innerHTML = "";
                            const inner = document.createElement("div");
                            inner.className = "timeline-compare-track-inner";
                            inner.style.width = totalWidth + "px";
                            trackElement.appendChild(inner);

                            // Axe
                            const axis = document.createElement("div");
                            axis.className = "timeline-compare-axis";
                            axis.style.width = totalWidth + "px";
                            inner.appendChild(axis);

                            // Rep√®res d'ann√©es (seulement sur la frise du haut pour all√©ger)
                            if (side === "A") {
                                for (let y = start; y <= end; y += 50) {
                                    const label = document.createElement("div");
                                    label.className = "timeline-compare-year";
                                    label.textContent = y;
                                    const x = (y - start) * pxPerYear;
                                    label.style.left = x + "px";
                                    inner.appendChild(label);
                                }
                            }

                            const dotsArray = (side === "A") ? this.compareDotsA : this.compareDotsB;

                            events.forEach((ev, index) => {
                                const year = parseInt(ev.date.split("-")[0], 10);
                                if (isNaN(year)) return;

                                const xPos = (year - start) * pxPerYear;
                                const dot = document.createElement("div");
                                dot.className = `timeline-compare-dot timeline-compare-dot-${side}`;
                                dot.style.left = xPos + "px";

                                const description = `${ev.date} ‚Äî ${ev.titre}`;

                                dot.title = description;

                                dot.addEventListener("click", () => {
                                    this.syncComparisonSelection(side, index);
                                });

                                dotsArray.push(dot);
                                inner.appendChild(dot);
                            });
                        };

                        buildTrack(trackA, eventsA, "A");
                        buildTrack(trackB, eventsB, "B");

                        // Scroll synchronis√©
                        let isSyncing = false;

                        const syncScroll = (source, target) => {
                            if (isSyncing) return;
                            isSyncing = true;
                            target.scrollLeft = source.scrollLeft;
                            isSyncing = false;
                        };

                        trackA.addEventListener("scroll", () => syncScroll(trackA, trackB));
                        trackB.addEventListener("scroll", () => syncScroll(trackB, trackA));

                        // S√©lection par d√©faut : premier √©v√©nement du pays A (ou B si A vide)
                        if (eventsA.length > 0) {
                            this.syncComparisonSelection("A", 0);
                        } else if (eventsB.length > 0) {
                            this.syncComparisonSelection("B", 0);
                        }
                    }

                    // Trouve l'index dans eventsOther le plus proche en ann√©e
                    findNearestIndexByYear(eventsOther, targetYear) {
                        if (!eventsOther || eventsOther.length === 0) return null;

                        let bestIndex = 0;
                        let bestDiff = Infinity;

                        eventsOther.forEach((ev, idx) => {
                            const year = parseInt(ev.date.split("-")[0], 10);
                            if (isNaN(year)) return;
                            const diff = Math.abs(year - targetYear);
                            if (diff < bestDiff) {
                                bestDiff = diff;
                                bestIndex = idx;
                            }
                        });

                        return bestIndex;
                    }

                    // S√©lection synchronis√©e : dots + cartes
                    syncComparisonSelection(side, index) {
                        this.selectedComparisonSide = side;
                        this.selectedComparisonIndex = index;

                        const eventsA = this.compareEventsA || [];
                        const eventsB = this.compareEventsB || [];
                        const dotsA = this.compareDotsA || [];
                        const dotsB = this.compareDotsB || [];

                        if (side === "A" && (!eventsA[index])) return;
                        if (side === "B" && (!eventsB[index])) return;

                        const primaryEvents = (side === "A") ? eventsA : eventsB;
                        const otherEvents   = (side === "A") ? eventsB : eventsA;
                        const primaryDots   = (side === "A") ? dotsA : dotsB;
                        const otherDots     = (side === "A") ? dotsB : dotsA;

                        const primaryTrack  = document.getElementById(side === "A" ? "timeline-track-A" : "timeline-track-B");
                        const otherTrack    = document.getElementById(side === "A" ? "timeline-track-B" : "timeline-track-A");

                        const ev = primaryEvents[index];
                        if (!ev) return;

                        const targetYear = parseInt(ev.date.split("-")[0], 10);

                        const otherIndex = this.findNearestIndexByYear(otherEvents, targetYear);

                        // Nettoyer les s√©lections pr√©c√©dentes
                        [...dotsA, ...dotsB].forEach(dot => dot.classList.remove("selected"));
                        document.querySelectorAll(".compare-event").forEach(card => {
                            card.classList.remove("highlight-compare");
                        });

                        // S√©lection c√¥t√© principal
                        const primaryDot = primaryDots[index];
                        if (primaryDot) {
                            primaryDot.classList.add("selected");
                            this.centerDotInTrack(primaryTrack, primaryDot);
                        }

                        // S√©lection c√¥t√© oppos√©
                        if (otherIndex !== null && otherDots[otherIndex]) {
                            const otherDot = otherDots[otherIndex];
                            otherDot.classList.add("selected");
                            this.centerDotInTrack(otherTrack, otherDot);
                        }

                        // Highlight des cartes
                        const selectorPrimary = `.compare-event[data-side="${side}"][data-index="${index}"]`;
                        const selectorOther   = `.compare-event[data-side="${side === "A" ? "B" : "A"}"][data-index="${otherIndex}"]`;

                        const cardPrimary = document.querySelector(selectorPrimary);
                        const cardOther   = document.querySelector(selectorOther);

                        if (cardPrimary) cardPrimary.classList.add("highlight-compare");
                        if (cardOther)   cardOther.classList.add("highlight-compare");
                    }

                    // Centre un dot dans son track
                    centerDotInTrack(track, dot) {
                        if (!track || !dot) return;
                        const x = dot.offsetLeft;
                        const targetScroll = Math.max(0, x - track.clientWidth / 2);
                        track.scrollTo({
                            left: targetScroll,
                            behavior: "smooth"
                        });
                    }

                    // Ajuster la vue de la carte pour voir les deux pays
                    highlightComparisonCountries(countryA, countryB) {
                        const countryObjA = this.cache.countries.find(
                            c => c.pays.toLowerCase() === countryA.toLowerCase()
                        );
                        const countryObjB = this.cache.countries.find(
                            c => c.pays.toLowerCase() === countryB.toLowerCase()
                        );

                        if (countryObjA && countryObjB) {
                            try {
                                this.map.fitBounds([
                                    countryObjA.coordonnees,
                                    countryObjB.coordonnees
                                ]);
                            } catch (e) {
                                console.warn("Impossible d'ajuster la vue pour la comparaison:", e);
                            }
                        }
                    }

                    // Plus tard tu pourras changer les ic√¥nes / opacit√©. Pour l'instant on ne fait que laisser la carte telle quelle.
                    resetMapHighlights() {
                        // Placeholder si tu veux plus tard r√©initialiser des styles sp√©ciaux de comparaison
                    }
        }
        
        // ========================================
        // API PUBLIQUE POUR COMPATIBILIT√â
        // ========================================
        
        let historicalMap;
        
        function ajouterPays(nom, continent, latitude, longitude) {
            if (historicalMap) {
                const newCountry = {
                    pays: nom,
                    continent: continent,
                    coordonnees: [latitude, longitude]
                };
                historicalMap.cache.countries.push(newCountry);
                historicalMap.updateDisplay();
                historicalMap.showNotification(`‚úÖ Pays ajout√© : ${nom}`, 'success');
            }
        }
        
        function ajouterEvenement(pays, date, titre, description, categorie = 'general') {
            if (historicalMap) {
                const newEvent = {
                    pays: pays,
                    date: date,
                    titre: titre,
                    description: description,
                    categorie: categorie,
                    lien: '#'
                };
                historicalMap.cache.events.push(newEvent);
                historicalMap.updateDisplay();
                historicalMap.showNotification(`‚úÖ √âv√©nement ajout√© : ${titre}`, 'success');
            }
        }
        
        function synchroniserMaintenant() {
            if (historicalMap) {
                historicalMap.triggerSync();
            }
        }
        
        function activerSurveillance() {
            if (historicalMap && !historicalMap.watchMode) {
                historicalMap.toggleWatch();
            }
        }
        
        // ========================================
        // INITIALISATION
        // ========================================
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log("üöÄ Initialisation de la carte avec synchronisation Obsidian");
            
            historicalMap = new HistoricalMapWithSync();
            
            // Exposer pour le debugging
            window.historicalMap = historicalMap;
            window.ajouterPays = ajouterPays;
            window.ajouterEvenement = ajouterEvenement;
            window.synchroniserMaintenant = synchroniserMaintenant;
            window.activerSurveillance = activerSurveillance;
            
            console.log("‚úÖ Application avec sync Obsidian initialis√©e !");
            console.log("üí° Nouvelles commandes disponibles :");
            console.log("- synchroniserMaintenant()");
            console.log("- activerSurveillance()");
        });
        
        // Gestion des erreurs globales
        window.addEventListener('error', function(e) {
            console.error('Erreur JavaScript:', e.error);
            if (historicalMap) {
                historicalMap.showNotification('‚ùå Une erreur est survenue', 'error');
            }
        });
    </script>
</body>
</html>
